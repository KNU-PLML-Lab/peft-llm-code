Minimum number of coins having value equal to powers of 2 required to obtain N | C program for above approach ; Function to count of set bit in N ; Stores count of set bit in N ; Iterate over the range [ 0 , 31 ] ; If current bit is set ; Update result ; Driver Code
Logarithm tricks for Competitive Programming | C implementation to check that a integer is a power of Two ; Function to check if the number is a power of two ; Driver Code
Ternary representation of Cantor set | C implementation to find the cantor set for n levels and for a given start_num and end_num ; The Linked List Structure for the Cantor Set ; Function to initialize the Cantor Set List ; Function to propogate the list by adding new nodes for the next levels ; Modifying the start and end values for the next level ; Changing the pointers to the next node ; Recursively call the function to generate the Cantor Set for the entire level ; Function to print a level of the Set ; Function to build and display the Cantor Set for each level ; Driver code
Optimized Naive Algorithm for Pattern Searching | C program for A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different ; A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different ; For current index i , check for pattern match ; if ( j == M ) if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; slide the pattern by j ; Driver program to test above function
Program to Encrypt a String using ! and @ | C program to Encrypt the String using ! and @ ; Function to encrypt the string ; evenPos is for storing encrypting char at evenPosition oddPos is for storing encrypting char at oddPosition ; Get the number of times the character is to be repeated ; if i is odd , print ' ! ' else print ' @ ' ; Driver code ; Encrypt the String
Recursive function to check if a string is palindrome | A recursive C program to check whether a given number is palindrome or not ; A recursive function that check a str [ s . . e ] is palindrome or not . ; If there is only one character ; If first and last characters do not match ; If there are more than two characters , check if middle substring is also palindrome or not . ; An empty string is considered as palindrome ; Driver Code
Write your own atoi ( ) | A simple C ++ program for implementation of atoi ; if whitespaces then ignore . ; sign of number ; checking for valid input ; handling overflow test case ; Driver Code ; Functional Code
Fill two instances of all numbers from 1 to n in a specific way | A backtracking based C Program to fill two instances of all numbers from 1 to n in a specific way ; A recursive utility function to fill two instances of numbers from 1 to n in res [ 0. .2 n - 1 ] . ' curr ' is current value of n . ; If current number becomes 0 , then all numbers are filled ; Try placing two instances of ' curr ' at all possible locations till solution is found ; Two ' curr ' should be placed at ' curr + 1' distance ; Plave two instances of ' curr ' ; Recur to check if the above placement leads to a solution ; If solution is not possible , then backtrack ; This function prints the result for input number ' n ' using fillUtil ( ) ; Create an array of size 2 n and initialize all elements in it as 0 ; If solution is possible , then print it . ; Driver program
Check if N contains all digits as K in base B | C implementation of the approach ; Function to print the number of digits ; Calculate log using base change property and then take its floor and then add 1 ; Return the output ; Function that returns true if n contains all one 's in base b ; Calculate the sum ; Driver code ; Given number N ; Given base B ; Given digit K ; Function call
Program to Calculate the Perimeter of a Decagon | C program to Calculate the Perimeter of a Decagon ; Function for finding the perimeter ; Driver code
Angle between two Planes in 3D | C program to find the Angle between two Planes in 3 D . ; Function to find Angle ; Driver Code
Mirror of a point through a 3 D plane | C program to find Mirror of a point through a 3 D plane ; Function to mirror image ; Driver Code ; function call
Change a Binary Tree so that every node stores sum of all nodes in left subtree | C program to store sum of nodes in left subtree in every node ; A tree node ; Function to modify a Binary Tree so that every node stores sum of values in its left child including its own value ; Base cases ; Update left and right subtrees ; Add leftsum to current node ; Return sum of values under root ; Utility function to do inorder traversal ; Utility function to create a new node ; Driver program ; Let us construct below tree 1 / \ 2 3 / \ \ 4 5 6
The Stock Span Problem | C program for brute force method to calculate stock span values ; Fills array S [ ] with span values ; Span value of first day is always 1 ; Calculate span value of remaining days by linearly checking previous days ; Initialize span value ; Traverse left while the next element on left is smaller than price [ i ] ; A utility function to print elements of array ; Driver program to test above function ; Fill the span values in array S [ ] ; print the calculated span values
Next Greater Element | Simple C program to print next greater elements in a given array ; prints element and NGE pair for all elements of arr [ ] of size n ; Driver Code
Convert a Binary Tree into its Mirror Tree | C program to convert a binary tree to its mirror ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Change a tree so that the roles of the left and right pointers are swapped at every node . So the tree ... 4 / \ 2 5 / \ 1 3 is changed to ... 4 / \ 5 2 / \ 3 1 ; do the subtrees ; swap the pointers in this node ; Helper function to print Inorder traversal . ; Driver program to test mirror ( ) ; Print inorder traversal of the input tree ; Convert tree to its mirror ; Print inorder traversal of the mirror tree
Foldable Binary Trees |  ; A binary tree node has data , pointer to left child and a pointer to right child ; A utility function that checks if trees with roots as n1 and n2 are mirror of each other ; Returns true if the given tree can be folded ; A utility function that checks if trees with roots as n1 and n2 are mirror of each other ; If both left and right subtrees are NULL , then return true ; If one of the trees is NULL and other is not , then return false ; Otherwise check if left and right subtrees are mirrors of their counterparts ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test mirror ( ) ; The constructed binary tree is 1 / \ 2 3 \ / 4 5
Check for Children Sum Property in a Binary Tree | Program to check children sum property ; A binary tree node has data , left child and right child ; returns 1 if children sum property holds for the given node and both of its children ; left_data is left child data and right_data is for right child data ; If node is NULL or it 's a leaf node then  return true  ; If left child is not present then 0 is used as data of left child ; If right child is not present then 0 is used as data of right child ; if the node and both of its children satisfy the property return 1 else 0 ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above function
Program to find HCF ( Highest Common Factor ) of 2 Numbers | C program to find GCD of two numbers ; Recursive function to return gcd of a and b ; Everything divides 0 ; base case ; a is greater ; Driver program to test above function
Josephus Problem Using Bit Magic | C program for josephus problem ; function to find the position of the Most Significant Bit ; keeps shifting bits to the right until we are left with 0 ; function to return at which place Josephus should sit to avoid being killed ; Getting the position of the Most Significant Bit ( MSB ) . The leftmost '1' . If the number is '41' then its binary is '101001' . So msbPos ( 41 ) = 6 ; ' j ' stores the number with which to XOR the number ' n ' . Since we need '100000' We will do 1 << 6 - 1 to get '100000' ; Toggling the Most Significant Bit . Changing the leftmost '1' to '0' . 101001 ^ 100000 = 001001 ( 9 ) ; Left - shifting once to add an extra '0' to the right end of the binary number 001001 = 010010 ( 18 ) ; Toggling the '0' at the end to '1' which is essentially the same as putting the MSB at the rightmost place . 010010 | 1 = 010011 ( 19 ) ; hard coded driver main function to run the program
Sum of Bitwise And of all pairs in a given array | An efficient C ++ program to compute sum of bitwise AND of all pairs ; Returns value of " arr [ 0 ] ▁ & ▁ arr [ 1 ] ▁ + ▁ arr [ 0 ] ▁ & ▁ arr [ 2 ] ▁ + ▁ . . . ▁ arr [ i ] ▁ & ▁ arr [ j ] ▁ + ▁ . . . . . ▁ arr [ n - 2 ] ▁ & ▁ arr [ n - 1 ] " ; Traverse over all bits ; Count number of elements with i 'th bit set  int k = 0; Initialize the count ; There are k set bits , means k ( k - 1 ) / 2 pairs . Every pair adds 2 ^ i to the answer . Therefore , we add "2 ^ i ▁ * ▁ [ k * ( k - 1 ) / 2 ] " to the answer . ; Driver program to test above function
Puzzle | Program to find number of squares in a chessboard | Function to return count of squares ; ; A better way to write n * ( n + 1 ) * ( 2 n + 1 ) / 6 ; Driver Code
Program to find GCD or HCF of two numbers | C program to find GCD of two numbers ; Recursive function to return gcd of a and b ; Everything divides 0 ; base case ; a is greater ; Driver program to test above function
Construct XOR tree by Given leaf nodes of Perfect Binary Tree | C program to build xor tree by leaf nodes of perfect binary tree and root node value of tree ; maximum size for xor tree ; Allocating space to xor tree ; A recursive function that constructs xor tree for array [ start ... . . end ] . x is index of current node in xor tree st ; If there is one element in array , store it in current node of xor tree and return ; printf ( " % d ▁ " , xortree [ x ] ) ; ; for left subtree ; for right subtree ; for getting the middle index from corner indexes . ; Build the left and the right subtrees by xor operation ; merge the left and right subtrees by XOR operation ; Function to construct XOR tree from given array . This function calls construct_Xor_Tree_Util ( ) to fill the allocated memory of xort array ; Driver Code ; leaf nodes of Binary Tree ; Build the xor tree ; Height of xor tree ; Maximum size of xor tree ; Root node is at index 0 considering 0 - based indexing in XOR Tree ; print value at root node
How to swap two bits in a given integer ? | C code for swapping given bits of a number ; left - shift 1 p1 and p2 times and using XOR ; Driver Code
Check if two nodes are cousins in a Binary Tree | C program to check if two Nodes in a binary tree are cousins ; A Binary Tree Node ; A utility function to create a new Binary Tree Node ; Recursive function to check if two Nodes are siblings ; Base case ; Recursive function to find level of Node ' ptr ' in a binary tree ; base cases ; Return level if Node is present in left subtree ; Else search in right subtree ; Returns 1 if a and b are cousins , otherwise 0 ; 1. The two Nodes should be on the same level in the binary tree . 2. The two Nodes should not be siblings ( means that they should not have the same parent Node ) . ; Driver Program to test above functions
Check if all leaves are at same level | C program to check if all leaves are at same level ; A binary tree node ; A utility function to allocate a new tree node ; Recursive function which checks whether all leaves are at same level ; Base case ; If a leaf node is encountered ; When a leaf node is found first time ; Set first found leaf 's level ; If this is not first leaf node , compare its level with first leaf 's level ; If this node is not leaf , recursively check left and right subtrees ; The main function to check if all leafs are at same level . It mainly uses checkUtil ( ) ; Driver program to test above function ; Let us create tree shown in thirdt example
Check whether a binary tree is a full binary tree or not | C program to check whether a given Binary Tree is full or not ; Tree node structure ; Helper function that allocates a new node with the given key and NULL left and right pointer . ; This function tests if a binary tree is a full binary tree . ; If empty tree ; If leaf node ; If both left and right are not NULL , and left & right subtrees are full ; We reach here when none of the above if conditions work ; Driver Program
Print alternate elements of an array | C program to implement the above approach ; Function to print Alternate elements of the given array ; Print elements at odd positions ; Print elements of array ; Driver Code
Write Code to Determine if Two Trees are Identical |  ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Given two trees , return true if they are structurally identical ; 1. both empty ; 2. both non - empty -> compare them ; 3. one empty , one not -> false ; Driver program to test identicalTrees function
Print cousins of a given node in Binary Tree | C program to print cousins of a node ; A Binary Tree Node ; A utility function to create a new Binary Tree Node ; It returns level of the node if it is present in tree , otherwise returns 0. ; base cases ; If node is present in left subtree ; If node is not present in left subtree ; Print nodes at a given level such that sibling of node is not printed if it exists ; Base cases ; If current node is parent of a node with given level ; Recur for left and right subtrees ; This function prints cousins of a given node ; Get level of given node ; Print nodes of given level . ; Driver Program to test above functions
Given a binary tree , print out all of its root | program to print all of its root - to - leaf paths for a tree ; A binary tree node has data , pointer to left child and a pointer to right child ; Function prototypes ; Given a binary tree , print out all of its root - to - leaf paths , one per line . Uses a recursive helper to do the work . ; Recursive helper function -- given a node , and an array containing the path from the root node up to but not including this node , print out all the root - leaf paths . ; append this node to the path array ; it 's a leaf, so print the path that led to here  ; otherwise try both subtrees ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Utility that prints out an array on a line ; Driver program to test mirror ( ) ; Print all root - to - leaf paths of the input tree
Introduction to Arrays |  ; Creating an integer array named arr of size 10. ; accessing element at 0 index and setting its value to 5. ; access and print value at 0 index we get the output as 5.
Block swap algorithm for array rotation |  ; Prototype for utility functions ; Return If number of elements to be rotated is zero or equal to array size ; If number of elements to be rotated is exactly half of array size ; If A is shorter ; If B is shorter ; function to print an array ; This function swaps d elements starting at index fi with d elements starting at index si ; Driver program to test above functions
Block swap algorithm for array rotation | C code for above implementation ; A is shorter ; B is shorter ; Finally , block swap A and B
Program to cyclically rotate an array by one |  ; swap ; i and j pointing to first and last element respectively ; Driver code
Program to sort an array of strings using Selection Sort | C program to implement selection sort for array of strings . ; Sorts an array of strings where length of every string should be smaller than MAX_LEN ; One by one move boundary of unsorted subarray ; Find the minimum element in unsorted array ; If min is greater than arr [ j ] ; Make arr [ j ] as minStr and update min_idx ; Swap the found minimum element with the first element ; Driver code ; Printing the array before sorting ; Printing the array after sorting
Rearrange an array such that ' arr [ j ] ' becomes ' i ' if ' arr [ i ] ' is ' j ' | Set 1 | A simple C program to rearrange contents of arr [ ] such that arr [ j ] becomes j if arr [ i ] is j ; A simple method to rearrange ' arr [ 0 . . n - 1 ] ' so that ' arr [ j ] ' becomes ' i ' if ' arr [ i ] ' is ' j ' ; Create an auxiliary array of same size ; Store result in temp [ ] ; Copy temp back to arr [ ] ; A utility function to print contents of arr [ 0. . n - 1 ] ; Driver program
Program to find largest element in an array | C program to find maximum in arr [ ] of size n ; C function to find maximum in arr [ ] of size n ; Initialize maximum element ; Traverse array elements from second and compare every element with current max ; Driver Code
Find Second largest element in an array | C program to find second largest element in an array ; Function to print the second largest elements ; There should be atleast two elements ; If current element is greater than first then update both first and second ; If arr [ i ] is in between first and second then update second ; Driver program to test above function
Maximum and minimum of an array using minimum number of comparisons | structure is used to return two values from minMax ( ) ; If there is only one element then return it as min and max both ; If there are more than one elements , then initialize min and max ; Driver program to test above function
Maximum and minimum of an array using minimum number of comparisons |  ; structure is used to return two values from minMax ( ) ; If array has even number of elements then initialize the first two elements as minimum and maximum ; set the starting index for loop ; If array has odd number of elements then initialize the first element as minimum and maximum ; set the starting index for loop ; In the while loop , pick elements in pair and compare the pair with max and min so far ; Increment the index by 2 as two elements are processed in loop ; Driver program to test above function
Minimum number of jumps to reach end | C program to find Minimum number of jumps to reach end ; Returns minimum number of jumps to reach arr [ h ] from arr [ l ] ; Base case : when source and destination are same ; When nothing is reachable from the given source ; Traverse through all the points reachable from arr [ l ] . Recursively get the minimum number of jumps needed to reach arr [ h ] from these reachable points . ; Driver program to test above function
Smallest subarray with sum greater than a given value |  ; Returns length of smallest subarray with sum greater than x . If there is no subarray with given sum , then returns n + 1 ; Initialize length of smallest subarray as n + 1 ; Pick every element as starting point ; Initialize sum starting with current start ; If first element itself is greater ; Try different ending points for curremt start ; add last element to current sum ; If sum becomes more than x and length of this subarray is smaller than current smallest length , update the smallest length ( or result ) ; Driver program to test above function
Tree Traversals ( Inorder , Preorder and Postorder ) | C program for different tree traversals ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Given a binary tree , print its nodes according to the " bottom - up " postorder traversal . ; first recur on left subtree ; then recur on right subtree ; now deal with the node ; Given a binary tree , print its nodes in inorder ; first recur on left child ; then print the data of node ; now recur on right child ; Given a binary tree , print its nodes in preorder ; first print data of node ; then recur on left sutree ; now recur on right subtree ; Driver program to test above functions
Remove all nodes which don 't lie in any path with sum>= k |  ; A Binary Tree Node ; A utility function to create a new Binary Tree node with given data ; print the tree in LVR ( Inorder traversal ) way . ; Main function which truncates the binary tree . ; Base Case ; Recur for left and right subtrees ; If we reach leaf whose data is smaller than sum , we delete the leaf . An important thing to note is a non - leaf node can become leaf when its chilren are deleted . ; Driver program to test above function
Merge an array of size n into another array of size m + n | C program to Merge an array of size n into another array of size m + n ; Assuming - 1 is filled for the places where element is not available ; Function to move m elements at the end of array mPlusN [ ] ; Merges array N [ ] of size n into array mPlusN [ ] of size m + n ; Current index of i / p part of mPlusN [ ] ; Current index of N [ ] ; Current index of output mPlusN [ ] ; Take an element from mPlusN [ ] if a ) value of the picked element is smaller and we have not reached end of it b ) We have reached end of N [ ] ; Otherwise take element from N [ ] ; Utility that prints out an array on a line ; Driver code ; Initialize arrays ; Move the m elements at the end of mPlusN ; Merge N [ ] into mPlusN [ ] ; Print the resultant mPlusN
Count of N | C program to implement the above approach ; Function to find maximum between two numbers ; Function to find minimum between two numbers ; Function to return the count of such numbers ; For 1 - digit numbers , the count is 10 irrespective of K ; dp [ j ] stores the number of such i - digit numbers ending with j ; Stores the results of length i ; Initialize count for 1 - digit numbers ; Compute values for count of digits greater than 1 ; Find the range of allowed numbers if last digit is j ; Perform Range update ; Prefix sum to find actual count of i - digit numbers ending with j ; Update dp [ ] ; Stores the final answer ; Return the final answer ; Driver Code
Count Inversions in an array | Set 1 ( Using Merge Sort ) | C program to Count Inversions in an array ; Driver program to test above functions
Two elements whose sum is closest to zero | C code to find Two elements whose sum is closest to zero ; Array should have at least two elements ; Initialization of values ; Driver program to test above function
Union and Intersection of two sorted arrays | C program to find union of two sorted arrays ; Function prints union of arr1 [ ] and arr2 [ ] m is the number of elements in arr1 [ ] n is the number of elements in arr2 [ ] ; Print remaining elements of the larger array ; Driver program to test above function
Union and Intersection of two sorted arrays | C program to find intersection of two sorted arrays ; Function prints Intersection of arr1 [ ] and arr2 [ ] m is the number of elements in arr1 [ ] n is the number of elements in arr2 [ ] ; Driver program to test above function ; Function calling
Find the maximum sum leaf to root path in a Binary Tree | C program to find maximum sum leaf to root path in Binary Tree ; A tree node structure ; A utility function that prints all nodes on the path from root to target_leaf ; base case ; return true if this node is the target_leaf or target leaf is present in one of its descendants ; This function Sets the target_leaf_ref to refer the leaf node of the maximum path sum . Also , returns the max_sum using max_sum_ref ; Update current sum to hold sum of nodes on path from root to this node ; If this is a leaf node and path to this node has maximum sum so far , then make this node target_leaf ; If this is not a leaf node , then recur down to find the target_leaf ; Returns the maximum sum and prints the nodes on max sum path ; base case ; find the target leaf and maximum sum ; print the path from root to the target leaf ; return maximum sum ; Utility function to create a new Binary Tree node ; Driver function to test above functions
Sort an array of 0 s , 1 s and 2 s | C program to sort an array with 0 , 1 and 2 in a single pass ; Function to swap * a and * b ; Sort the input array , the array is assumed to have values in { 0 , 1 , 2 } ; Utility function to print array arr [ ] ; driver program to test
Find the Minimum length Unsorted Subarray , sorting which makes the complete array sorted | C program to find the Minimum length Unsorted Subarray , sorting which makes the complete array sorted ; step 1 ( a ) of above algo ; step 1 ( b ) of above algo ; step 2 ( a ) of above algo ; step 2 ( b ) of above algo ; step 2 ( c ) of above algo ; step 3 of above algo
Count the number of possible triangles | C program to count number of triangles that can be formed from given array ; Following function is needed for library function qsort ( ) . Refer www . cplusplus . com / reference / clibrary / cstdlib / qsort / ; Function to count all possible triangles with arr [ ] elements ; Sort the array elements in non - decreasing order ; Initialize count of triangles ; Fix the first element . We need to run till n - 3 as the other two elements are selected from arr [ i + 1. . . n - 1 ] ; Initialize index of the rightmost third element ; Fix the second element ; Find the rightmost element which is smaller than the sum of two fixed elements The important thing to note here is , we use the previous value of k . If value of arr [ i ] + arr [ j - 1 ] was greater than arr [ k ] , then arr [ i ] + arr [ j ] must be greater than k , because the array is sorted . ; Total number of possible triangles that can be formed with the two fixed elements is k - j - 1. The two fixed elements are arr [ i ] and arr [ j ] . All elements between arr [ j + 1 ] / to arr [ k - 1 ] can form a triangle with arr [ i ] and arr [ j ] . One is subtracted from k because k is incremented one extra in above while loop . k will always be greater than j . If j becomes equal to k , then above loop will increment k , because arr [ k ] + arr [ i ] is always greater than arr [ k ] ; Driver program to test above functionarr [ j + 1 ]
Search , insert and delete in an unsorted array | C program to implement linear search in unsorted array ; Function to implement search operation ; Driver Code ; Using a last element as search element
Search , insert and delete in an unsorted array | C program to implement insert operation in an unsorted array . ; Inserts a key in arr [ ] of given capacity . n is current size of arr [ ] . This function returns n + 1 if insertion is successful , else n . ; Cannot insert more elements if n is already more than or equal to capcity ; Driver Code ; Inserting key
Search , insert and delete in an unsorted array | C program to implement delete operation in a unsorted array ; Function to implement search operation ; Function to delete an element ; Find position of element to be deleted ; Deleting element ; Driver code
Search , insert and delete in a sorted array | C program to implement binary search in sorted array ; function to implement binary search ; low + ( high - low ) / 2 ; ; Driver Code Let us search 3 in below array
Search , insert and delete in a sorted array | C program to implement insert operation in an sorted array . ; Inserts a key in arr [ ] of given capacity . n is current size of arr [ ] . This function returns n + 1 if insertion is successful , else n . ; Cannot insert more elements if n is already more than or equal to capcity ; Driver program to test above function ; Inserting key
Search , insert and delete in a sorted array | C program to implement delete operation in a sorted array ; To search a ley to be deleted ; Function to delete an element ; Find position of element to be deleted ; Deleting element ; Driver code
Equilibrium index of an array | C program to find equilibrium index of an array ; function to find the equilibrium index ; Check for indexes one by one until an equilibrium index is found ; get left sum ; get right sum ; if leftsum and rightsum are same , then we are done ; return - 1 if no equilibrium index is found ; Driver code
Equilibrium index of an array | C program to find equilibrium index of an array ; function to find the equilibrium index ; initialize sum of whole array ; initialize leftsum ; Find sum of the whole array ; sum is now right sum for index i ; If no equilibrium index found , then return 0 ; Driver code
Ceiling in a sorted array |  ; Function to get index of ceiling of x in arr [ low . . high ] ; If x is smaller than or equal to first element , then return the first element ; Otherwise , linearly search for ceil value ; if x lies between arr [ i ] and arr [ i + 1 ] including arr [ i + 1 ] , then return arr [ i + 1 ] ; If we reach here then x is greater than the last element of the array , return - 1 in this case ; Driver program to check above functions
Ceiling in a sorted array |  ; Function to get index of ceiling of x in arr [ low . . high ] ; If x is smaller than or equal to the first element , then return the first element ; If x is greater than the last element , then return - 1 ; get the index of middle element of arr [ low . . high ] ; If x is same as middle element , then return mid ; If x is greater than arr [ mid ] , then either arr [ mid + 1 ] is ceiling of x or ceiling lies in arr [ mid + 1. . . high ] ; If x is smaller than arr [ mid ] , then either arr [ mid ] is ceiling of x or ceiling lies in arr [ low ... mid - 1 ] ; Driver program to check above functions
Two Pointers Technique | Naive solution to find if there is a pair in A [ 0. . N - 1 ] with given sum . ; as equal i and j means same element ; pair exists ; as the array is sorted ; No pair found with given sum . ; Driver Code ; Function call
Two Pointers Technique |  ; Two pointer technique based solution to find if there is a pair in A [ 0. . N - 1 ] with a given sum . ; represents first pointer ; represents second pointer ; If we find a pair ; If sum of elements at current pointers is less , we move towards higher values by doing i ++ ; If sum of elements at current pointers is more , we move towards lower values by doing j -- ; Driver code ; array declaration ; value to search ; size of the array ; Function call
Assembly Line Scheduling | DP | A C program to find minimum possible time by the car chassis to complete ; Utility function to find minimum of two numbers ; time taken to leave first station in line 1 ; time taken to leave first station in line 2 ; Fill tables T1 [ ] and T2 [ ] using the above given recursive relations ; Consider exit times and retutn minimum ; Driver Code
Minimum insertions to form a palindrome | DP | A Dynamic Programming based program to find minimum number insertions needed to make a string palindrome ; A utility function to find minimum of two integers ; A DP function to find minimum number of insertions ; Create a table of size n * n . table [ i ] [ j ] will store minimum number of insertions needed to convert str [ i . . j ] to a palindrome . ; Fill the table ; Return minimum number of insertions for str [ 0. . n - 1 ] ; Driver program to test above function .
Largest Independent Set Problem | DP | A naive recursive implementation of Largest Independent Set problem ; A utility function to find max of two integers ; A binary tree node has data , pointer to left child and a pointer to right child ; The function returns size of the largest independent set in a given binary tree ; Calculate size excluding the current node ; Calculate size including the current node ; Return the maximum of two sizes ; A utility function to create a node ; Driver program to test above functions ; Let us construct the tree given in the above diagram
Maximum Length Chain of Pairs | DP |  ; This function assumes that arr [ ] is sorted in increasing order according the first ( or smaller ) values in pairs . ; Initialize MCL ( max chain length ) values for all indexes ; Compute optimized chain length values in bottom up manner ; Pick maximum of all MCL values ; Driver program to test above function
Palindrome Partitioning | DP | Dynamic Programming Solution for Palindrome Partitioning Problem ; Returns the minimum number of cuts needed to partition a string such that every part is a palindrome ; Get the length of the string ; Create two arrays to build the solution in bottom up manner C [ i ] [ j ] = Minimum number of cuts needed for palindrome partitioning of substring str [ i . . j ] P [ i ] [ j ] = true if substring str [ i . . j ] is palindrome , else false Note that C [ i ] [ j ] is 0 if P [ i ] [ j ] is true ; different looping variables ; Every substring of length 1 is a palindrome ; L is substring length . Build the solution in bottom up manner by considering all substrings of length starting from 2 to n . The loop structure is same as Matrix Chain Multiplication problem ( See https : www . geeksforgeeks . org / matrix - chain - multiplication - dp - 8 / ) ; For substring of length L , set different possible starting indexes ; Set ending index ; If L is 2 , then we just need to compare two characters . Else need to check two corner characters and value of P [ i + 1 ] [ j - 1 ] ; IF str [ i . . j ] is palindrome , then C [ i ] [ j ] is 0 ; Make a cut at every possible location starting from i to j , and get the minimum cost cut . ; Return the min cut value for complete string . i . e . , str [ 0. . n - 1 ] ; Driver program to test above function
Boyer Moore Algorithm for Pattern Searching | C Program for Bad Character Heuristic of Boyer Moore String Matching Algorithm ; A utility function to get maximum of two integers ; The preprocessing function for Boyer Moore 's bad character heuristic ; Initialize all occurrences as - 1 ; Fill the actual value of last occurrence of a character ; A pattern searching function that uses Bad Character Heuristic of Boyer Moore Algorithm ; Fill the bad character array by calling the preprocessing function badCharHeuristic ( ) for given pattern ; s is shift of the pattern with respect to text ; Keep reducing index j of pattern while characters of pattern and text are matching at this shift s ; If the pattern is present at current shift , then index j will become - 1 after the above loop ; Shift the pattern so that the next character in text aligns with the last occurrence of it in pattern . The condition s + m < n is necessary for the case when pattern occurs at the end of text ; Shift the pattern so that the bad character in text aligns with the last occurrence of it in pattern . The max function is used to make sure that we get a positive shift . We may get a negative shift if the last occurrence of bad character in pattern is on the right side of the current character . ; Driver program to test above function
Difference between sums of odd level and even level nodes of a Binary Tree | A recursive program to find difference between sum of nodes at odd level and sum at even level ; Binary Tree node ; A utility function to allocate a new tree node with given data ; The main function that return difference between odd and even level nodes ; Base case ; Difference for root is root 's data - difference for  left subtree - difference for right subtree ; Driver program to test above functions
Root to leaf path sum equal to a given number |  ; A binary tree node has data , pointer to left child and a pointer to right child ; Given a tree and a sum , return true if there is a path from the root down to a leaf , such that adding up all the values along the path equals the given sum . Strategy : subtract the node value from the sum when recurring down , and check to see if the sum is 0 when you run out of tree . ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver Code ; Constructed binary tree is 10 / \ 8 2 / \ / 3 5 2
Sum of all the numbers that are formed from root to leaf paths | C program to find sum of all paths from root to leaves ; function to allocate new node with given data ; Returns sum of all root to leaf paths . The first parameter is root of current subtree , the second parameter is value of the number formed by nodes from root to this node ; Base case ; Update val ; if current node is leaf , return the current value of val ; recur sum of values for left and right subtree ; A wrapper function over treePathsSumUtil ( ) ; Pass the initial value as 0 as there is nothing above root ; Driver function to test the above functions
Lowest Common Ancestor in a Binary Tree | Set 2 ( Using Parent Pointer ) | C ++ program to find lowest common ancestor using parent pointer ; A Tree Node ; A utility function to create a new BST node ; A utility function to insert a new node with given key in Binary Search Tree ; If the tree is empty , return a new node ; Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; To find LCA of nodes n1 and n2 in Binary Tree ; Creata a map to store ancestors of n1 ; Insert n1 and all its ancestors in map ; Check if n2 or any of its ancestors is in map . ; Driver method to test above functions
Chocolate Distribution Problem | Set 2 | C program for above approach ; Function to return minimum number of chocolates ; decreasing sequence ; add the chocolates received by that person ; end point of decreasing sequence ; val = 1 ; reset value at that index ; increasing sequence ; flat sequence ; add value of chocolates at position n - 1 ; Helper function to get sum of decreasing sequence ; value obtained from decreasing sequence also the count of values in the sequence ; assigning max of values obtained from increasing and decreasing sequences ; sum of count - 1 values & peak value sum of natural numbers : ( n * ( n + 1 ) ) / 2 ; Driver code
Program to find sum of harmonic series | C program to find sum of harmonic series ; Function to return sum of harmonic series ; Driver code
Find nth term of the series 5 2 13 41 | C program to find nth term of the series 5 2 13 41 ; function to calculate nth term of the series ; to store the nth term of series ; if n is even number ; if n is odd number ; return nth term ; Driver code
Logarithm | C program to find log ( n ) using Recursion ; Driver code
Find amount to be added to achieve target ratio in a given mixture | C program to find amount of water to be added to achieve given target ratio . ; Driver code
Average of Squares of Natural Numbers | C program to get the Average of Square of first n natural numbers ; Function to get the average ; Driver Code
Program to print triangular number series till n | C Program to find Triangular Number Series ; Function to find triangular number ; Driven Function
Sum of all divisors from 1 to n | C program to find sum of all divisor of number up to ' n ' ; Utility function to find sum of all divisor of number up to ' n ' ; Driver code
Sum of the Series 1 + x / 1 + x ^ 2 / 2 + x ^ 3 / 3 + . . + x ^ n / n | C program to find sum of series 1 + x / 1 + x ^ 2 / 2 + x ^ 3 / 3 + ... . + x ^ n / n ; Code to print the sum of the series ; Driver code
Find whether a given integer is a power of 3 or not | C ++ program to check if a number is power of 3 or not . ; Returns true if n is power of 3 , else false ; The maximum power of 3 value that integer can hold is 1162261467 ( 3 ^ 19 ) . ; Driver code
Program for Perrin numbers | Optimized C program for n 'th perrin number ; Driver code
Check if count of divisors is even or odd | Naive Solution to find if count of divisors is even or odd ; Function to count the divisors ; Initialize count of divisors ; Note that this loop runs till square root ; If divisors are equal increment count by one Otherwise increment count by 2 ; Driver Code
How to avoid overflow in modular multiplication ? | A Simple solution that causes overflow when value of ( a % mod ) * ( b % mod ) becomes more than maximum value of long long int
Count number of squares in a rectangle | C program to count squares in a rectangle of size m x n ; Returns count of all squares in a rectangle of size m x n ; If n is smaller , swap m and n ; Now n is greater dimension , apply formula ; Driver Code
Program to find sum of series 1 + 1 / 2 + 1 / 3 + 1 / 4 + . . + 1 / n | C program to find sum of series ; Function to return sum of 1 / 1 + 1 / 2 + 1 / 3 + . . + 1 / n ; Driver code
Program to find GCD or HCF of two numbers | C program to find GCD of two numbers ; Recursive function to return gcd of a and b ; Driver program to test above function
Print all sequences of given length | C ++ program of above approach ; A utility function that prints a given arr [ ] of length size ; The core function that recursively generates and prints all sequences of length k ; A function that uses printSequencesRecur ( ) to prints all sequences from 1 , 1 , . .1 to n , n , . . n ; Driver Program to test above functions
Check if a number is multiple of 5 without using / and % operators | C program for the above approach ; assumes that n is a positive integer ; Driver Code
Count total bits in a number | Function to get no of bits in binary representation of positive integer ; Driver program
Find the n | C program to find n - th number whose binary representation is palindrome . ; Finds if the kth bit is set in the binary representation ; Returns the position of leftmost set bit in the binary representation ; Finds whether the integer in binary representation is palindrome or not ; One by one compare bits ; Compare left and right bits and converge ; Start from 1 , traverse through all the integers ; If we reach n , break the loop ; Driver code ; Function Call
Bitwise Operators in C / C ++ | C Program to demonstrate use of bitwise operators ; a = 5 ( 00000101 ) , b = 9 ( 00001001 ) ; The result is 00000001 ; The result is 00001101 ; The result is 00001100 ; The result is 11111010 ; The result is 00010010 ; The result is 00000100
Convert a given temperature to another system based on given boiling and freezing points | C program for above approach ; Function to return temperature in the second thermometer ; Calculate the temperature ; Driver Code
Write a Program to Find the Maximum Depth or Height of a Tree |  ; A binary tree node has data , pointer to left child and a pointer to right child ; Compute the " maxDepth " of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node . ; compute the depth of each subtree ; use the larger one ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver code
How to determine if a binary tree is height | C program to check if a tree is height - balanced or not ; A binary tree node has data , pointer to left child and a pointer to right child ; Returns the height of a binary tree ; Returns true if binary tree with root as root is height - balanced ; for height of left subtree ; for height of right subtree ; If tree is empty then return true ; Get the height of left and right sub trees ; If we reach here then tree is not height - balanced ; returns maximum of two integers ; The function Compute the " height " of a tree . Height is the number of nodes along the longest path from the root node down to the farthest leaf node . ; base case tree is empty ; If tree is not empty then height = 1 + max of left height and right heights ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver code
Diameter of a Binary Tree | Recursive optimized C program to find the diameter of a Binary Tree ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; returns max of two integers ; The function Compute the " height " of a tree . Height is the number f nodes along the longest path from the root node down to the farthest leaf node . ; base case tree is empty ; If tree is not empty then height = 1 + max of left height and right heights ; Function to get diameter of a binary tree ; base case where tree is empty ; get the height of left and right sub - trees ; get the diameter of left and right sub - trees ; Return max of following three 1 ) Diameter of left subtree 2 ) Diameter of right subtree 3 ) Height of left subtree + height of right subtree + 1 ; Driver Code ; Constructed binary tree is 1 / \ 2 3 / \ 4 5 ; Function Call
Find if possible to visit every nodes in given Graph exactly once based on given conditions | C ++ program for above approach . ; Function to find print path ; If a [ 0 ] is 1 ; Printing path ; Seeking for a [ i ] = 0 and a [ i + 1 ] = 1 ; Printing path ; If a [ N - 1 ] = 0 ; Driver Code ; Given Input ; Function Call
Find depth of the deepest odd level leaf node | C program to find depth of the deepest odd level leaf node ; A utility function to find maximum of two integers ; A Binary Tree node ; A utility function to allocate a new tree node ; A recursive function to find depth of the deepest odd level leaf ; Base Case ; If this node is a leaf and its level is odd , return its level ; If not leaf , return the maximum value from left and right subtrees ; Main function which calculates the depth of deepest odd level leaf . This function mainly uses depthOfOddLeafUtil ( ) ; Driver program to test above functions
Reorder an array such that sum of left half is not equal to sum of right half | C program for the above approach ; A comparator function used by qsort ; Function to print the required reordering of array if possible ; Sort the array in increasing order ; If all elements are equal , then it is not possible ; Else print the sorted array arr [ ] ; Driver Code ; Given array ; Function call
Maximum width of a binary tree | C program to calculate width of binary tree ; A binary tree node has data , pointer to left child and a pointer to right child ; Function protoypes ; Function to get the maximum width of a binary tree ; Get width of each level and compare the width with maximum width so far ; Get width of a given level ; Compute the " height " of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node . ; compute the height of each subtree ; use the larger one ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver code ; Constructed binary tree is : 1 / \ 2 3 / \ \ 4 5 8 / \ 6 7 ; Function call
Maximum width of a binary tree | C program to calculate width of binary tree ; A binary tree node has data , pointer to left child and a pointer to right child ; A utility function to get height of a binary tree ; Function to get the maximum width of a binary tree ; Create an array that will store count of nodes at each level ; Fill the count array using preorder traversal ; Return the maximum value from count array ; A function that fills count array with count of nodes at every level of given binary tree ; Compute the " height " of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node . ; compute the height of each subtree ; use the larger one ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Return the maximum value from count array ; Driver program to test above functions ; Constructed bunary tree is : 1 / \ 2 3 / \ \ 4 5 8 / \ 6 7
Program to count leaf nodes in a binary tree | C implementation to find leaf count of a given Binary tree ; A binary tree node has data , pointer to left child and a pointer to right child ; Function to get the count of leaf nodes in a binary tree ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above functions ; create a tree ; get leaf count of the above created tree
Greedy Algorithm to find Minimum number of Coins | C program to find minimum number of denominations ; All denominations of Indian Currency ; Initialize result ; Traverse through all denomination ; Find denominations ; Print result ; Driver Code
Connect nodes at same level using constant extra space | Iterative C program to connect nodes at same level using constant extra space ; Constructor that allocates a new node with the given data and NULL left and right pointers . ; This function returns the leftmost child of nodes at the same level as p . This function is used to getNExt right of p 's right child  If right child of is NULL then this can also be used for the left child  ; Traverse nodes at p ' s ▁ level ▁ and ▁ find ▁ and ▁ return ▁ ▁ the ▁ first ▁ node ' s first child ; If all the nodes at p 's level are leaf nodes then return NULL ; Sets nextRight of all nodes of a tree with root as p ; Set nextRight for root ; set nextRight of all levels one by one ; Connect all childrem nodes of p and children nodes of all other nodes at same level as p ; Set the nextRight pointer for p 's left child ; If q has right child , then right child is nextRight of p and we also need to set nextRight of right child ; Set nextRight for other nodes in pre order fashion ; start from the first node of next level ; Driver program to test above functions ; Constructed binary tree is 10 / \ 8 2 / \ 3 90 ; Populates nextRight pointer in all nodes ; Let us check the values of nextRight pointers
Connect nodes at same level | C program to connect nodes at same level using extended pre - order traversal ; A binary tree node ; Sets the nextRight of root and calls connectRecur ( ) for other nodes ; Set the nextRight for root ; Set the next right for rest of the nodes ( other than root ) ; Set next right of all descendents of p . Assumption : p is a compete binary tree ; Base case ; Set the nextRight pointer for p 's left child ; Set the nextRight pointer for p 's right child  p->nextRight will be NULL if p is the right  most child at its level ; Set nextRight for other nodes in pre order fashion ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above functions ; Constructed binary tree is 10 / \ 8 2 / 3 ; Populates nextRight pointer in all nodes ; Let us check the values of nextRight pointers
Minimum insertions to form a palindrome | DP | A Naive recursive program to find minimum number insertions needed to make a string palindrome ; A utility function to find minimum of two numbers ; Recursive function to find minimum number of insertions ; Base Cases ; Check if the first and last characters are same . On the basis of the comparison result , decide which subrpoblem ( s ) to call ; Driver program to test above functions
Longest Palindromic Subsequence | DP | C program of above approach ; A utility function to get max of two integers ; Returns the length of the longest palindromic subsequence in seq ; Base Case 1 : If there is only 1 character ; Base Case 2 : If there are only 2 characters and both are same ; If the first and last characters match ; If the first and last characters do not match ; Driver program to test above functions
Get Level of a node in a Binary Tree | C program to Get Level of a node in a Binary Tree ; A tree node structure ; Helper function for getLevel ( ) . It returns level of the data if data is present in tree , otherwise returns 0. ; Returns level of given data value ; Utility function to create a new Binary Tree node ; Driver code ; Constructing tree given in the above figure
Finite Automata algorithm for Pattern Searching | C program for Finite Automata Pattern searching Algorithm ; If the character c is same as next character in pattern , then simply increment state ; ns stores the result which is next state ; Start from the largest possible value and stop when you find a prefix which is also suffix ; This function builds the TF table which represents4 Finite Automata for a given pattern ; Prints all occurrences of pat in txt ; Process txt over FA . ; Driver program to test above function
Find mirror of a given node in Binary tree | C program to find the mirror Node in Binary tree ; A binary tree Node has data , pointer to left child and a pointer to right child ; create new Node and initialize it ; recursive function to find mirror of Node ; if any of the Node is none then Node itself and decendent have no mirror , so return none , no need to further explore ! ; if left Node is target Node , then return right 's key (that is mirror) and vice  versa  ; first recur external Nodes ; if no mirror found , recur internal Nodes ; interface for mirror search ; Driver ; target Node whose mirror have to be searched
Iterative Search for a key ' x ' in Binary Tree | Iterative level order traversal based method to search in Binary Tree ; A binary tree node has data , left child and right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; An iterative process to search an element x in a given binary tree ; Base Case ; Create an empty queue for level order traversal ; Enqueue Root and initialize height ; Queue based level order traversal ; See if current node is same as x ; Remove current node and enqueue its children ; Driver program
Populate Inorder Successor for all nodes | C # program to populate inorder traversal of all nodes ; An implementation that doesn 't use static variable A wrapper over populateNextRecur ; The first visited node will be the rightmost node next of the rightmost node will be NULL ; Set next of all descendants of p by traversing them in reverse Inorder ; First set the next pointer in right subtree ; Set the next as previously visited node in reverse Inorder ; Change the prev for subsequent node ; Finally , set the next pointer in right subtree
Given a binary tree , how do you remove all the half nodes ? | C program to remove all half nodes ; Binary tree node ;  ; For inorder traversal ; Removes all nodes with only one child and returns new root ( note that root may change ) ; if current nodes is a half node with left child NULL left , then it 's right child is  returned and replaces it in the given tree  ; if current nodes is a half node with right child NULL right , then it 's right child is  returned and replaces it in the given tree  ; Driver program
Program to print all substrings of a given string | C program for the above approach ; outermost for loop this is for the selection of starting point ; 2 nd for loop is for selection of ending point ; 3 rd loop is for printing from starting point to ending point ; changing the line after printing from starting point to ending point ; Driver Code ; calling the method to print the substring
Sudoku | Backtracking |  ; N is the size of the 2D matrix N * N ; A utility function to print grid ; Checks whether it will be legal to assign num to the given row , col ; Check if we find the same num in the similar row , we return 0 ; Check if we find the same num in the similar column , we return 0 ; Check if we find the same num in the particular 3 * 3 matrix , we return 0 ; Takes a partially filled - in grid and attempts to assign values to all unassigned locations in such a way to meet the requirements for Sudoku solution ( non - duplication across rows , columns , and boxes ) ; Check if we have reached the 8 th row and 9 th column ( 0 indexed matrix ) , we are returning true to avoid further backtracking ; Check if column value becomes 9 , we move to next row and column start from 0 ; Check if the current position of the grid already contains value > 0 , we iterate for next column ; Check if it is safe to place the num ( 1 - 9 ) in the given row , col -> we move to next column ; assigning the num in the current ( row , col ) position of the grid and assuming our assigned num in the position is correct ; Checking for next possibility with next column ; Removing the assigned num , since our assumption was wrong , and we go for next assumption with diff num value ; 0 means unassigned cells
Subset Sum | Backtracking |  ; prints subset found ; qsort compare function ; inputs s - set vector t - tuplet vector s_size - set size t_size - tuplet size so far sum - sum so far ite - nodes count target_sum - sum to be found ; We found sum ; constraint check ; Exclude previous added item and consider next candidate ; constraint check ; generate nodes along the breadth ; consider next level node ( along depth ) ; Wrapper that prints subsets that sum to target_sum ; sort the set ; Driver Code
Given an array A [ ] and a number x , check for pair in A [ ] with sum as x | C program to check if given array has 2 elements whose sum is equal to the given value ; function to check for the given sum in the array ; checking for condition ; Driver Code
Modular exponentiation ( Recursive ) | Recursive C program to compute modular power ; Base cases ; If B is even ; If B is odd ; Driver program to test above functions
Modular Exponentiation ( Power in Modular Arithmetic ) | Iterative Function to calculate ( x ^ y ) in O ( log y ) ; Initialize result ; If y is odd , multiply x with result ; y must be even now y = y / 2 ; Change x to x ^ 2
Egg Dropping Puzzle | DP |  ; A utility function to get maximum of two integers ; Function to get minimum number of trials needed in worst case with n eggs and k floors ; If there are no floors , then no trials needed . OR if there is one floor , one trial needed . ; We need k trials for one egg and k floors ; Consider all droppings from 1 st floor to kth floor and return the minimum of these values plus 1. ; Driver code
Binary Tree | Set 1 ( Introduction ) |  ; struct containing left and right child of current node and key value ; newNode ( ) allocates a new node with the given data and NULL left and right pointers . ; Driver code
Find maximum ( or minimum ) in Binary Tree | C program to find maximum and minimum in a Binary Tree ; A tree node ; A utility function to create a new node ; Returns maximum value in a given Binary Tree ; Base case ; Return maximum of 3 values : 1 ) Root 's data 2) Max in Left Subtree 3) Max in right subtree ; Driver code ; Function call
Find maximum ( or minimum ) in Binary Tree | Returns minimum value in a given Binary Tree
Extract Leaves of a Binary Tree in a Doubly Linked List | C program to extract leaves of a Binary Tree in a Doubly Linked List ; Structure for tree and linked list ; Main function which extracts all leaves from given Binary Tree . The function returns new root of Binary Tree ( Note that root may changeif Binary Tree has only one node ) . The function also sets * head_ref as head of doubly linked list . left pointer of tree is used as prev in DLL and right pointer is used as next ; Utility function for allocating node for Binary Tree . ; Utility function for printing tree in In - Order . ; Utility function for printing double linked list . ; Driver program to test above function
Find n | C program for nth nodes of inorder traversals ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Given a binary tree , print its nth nodes of inorder ; first recur on left child ; when count = n then print element ; now recur on right child ; Driver program to test above functions
QuickSort Tail Call Optimization ( Reducing worst case space to Log n ) | A Simple implementation of QuickSort that makes two two recursive calls . ; pi is partitioning index , arr [ p ] is now at right place ; Separately sort elements before partition and after partition
Count all possible strings that can be generated by placing spaces | C program to implement the above approach ; Function to count the number of strings that can be generated by placing spaces between pair of adjacent characters ; Length of the string ; Count of positions for spaces ; Count of possible strings ; Driver Code
Modify given array to make sum of odd and even indexed elements same | C ++ program for the above approach ; Function to modify array to make sum of odd and even indexed elements equal ; Stores the count of 0 s , 1 s ; Stores sum of odd and even indexed elements respectively ; Count 0 s ; Count 1 s ; Calculate odd_sum and even_sum ; If both are equal ; Print the original array ; Otherwise ; Print all the 0 s ; For checking even or odd ; Update total count of 1 s ; Print all 1 s ; Driver Code ; Given array arr [ ] ; Function Call
Count of N digit Numbers whose sum of every K consecutive digits is equal | C program for the above approach ; Function to count the number of N - digit numbers such that sum of every k consecutive digits are equal ; Range of numbers ; Extract digits of the number ; Store the sum of first K digits ; Check for every k - consecutive digits using sliding window ; Driver Code ; Given integer N and K
Find if possible to visit every nodes in given Graph exactly once based on given conditions | C ++ program for above approach . ; Function to find print path ; If a [ 0 ] is 1 ; Printing path ; Seeking for a [ i ] = 0 and a [ i + 1 ] = 1 ; Printing path ; If a [ N - 1 ] = 0 ; Driver Code ; Given Input ; Function Call
Printing Items in 0 / 1 Knapsack | CPP code for Dynamic Programming based solution for 0 - 1 Knapsack problem ; A utility function that returns maximum of two integers ; Prints the items which are put in a knapsack of capacity W ; Build table K [ ] [ ] in bottom up manner ; stores the result of Knapsack ; either the result comes from the top ( K [ i - 1 ] [ w ] ) or from ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] ) as in Knapsack table . If it comes from the latter one / it means the item is included . ; This item is included . ; Since this weight is included its value is deducted ; Driver code
Optimal Binary Search Tree | DP | A naive recursive implementation of optimal binary search tree problem ; A recursive function to calculate cost of optimal binary search tree ; Base cases if ( j < i ) no elements in this subarray ; one element in this subarray ; Get sum of freq [ i ] , freq [ i + 1 ] , ... freq [ j ] ; Initialize minimum value ; One by one consider all elements as root and recursively find cost of the BST , compare the cost with min and update min if needed ; Return minimum value ; The main function that calculates minimum cost of a Binary Search Tree . It mainly uses optCost ( ) to find the optimal cost . ; Here array keys [ ] is assumed to be sorted in increasing order . If keys [ ] is not sorted , then add code to sort keys , and rearrange freq [ ] accordingly . ; A utility function to get sum of array elements freq [ i ] to freq [ j ] ; Driver program to test above functions
Word Wrap Problem | DP | A Dynamic programming solution for Word Wrap Problem ; A utility function to print the solution ; l [ ] represents lengths of different words in input sequence . For example , l [ ] = { 3 , 2 , 2 , 5 } is for a sentence like " aaa ▁ bb ▁ cc ▁ ddddd " . n is size of l [ ] and M is line width ( maximum no . of characters that can fit in a line ) ; extras [ i ] [ j ] will have number of extra spaces if words from i to j are put in a single line ; lc [ i ] [ j ] will have cost of a line which has words from i to j ; c [ i ] will have total cost of optimal arrangement of words from 1 to i ; p [ ] is used to print the solution . ; calculate extra spaces in a single line . The value extra [ i ] [ j ] indicates extra spaces if words from word number i to j are placed in a single line ; Calculate line cost corresponding to the above calculated extra spaces . The value lc [ i ] [ j ] indicates cost of putting words from word number i to j in a single line ; Calculate minimum cost and find minimum cost arrangement . The value c [ j ] indicates optimized cost to arrange words from word number 1 to j . ; Driver program to test above functions
Egg Dropping Puzzle | DP | A Dynamic Programming based for the Egg Dropping Puzzle ; A utility function to get maximum of two integers ; Function to get minimum number of trials needed in worst case with n eggs and k floors ; A 2D table where entry eggFloor [ i ] [ j ] will represent minimum number of trials needed for i eggs and j floors . ; We need one trial for one floor and 0 trials for 0 floors ; We always need j trials for one egg and j floors . ; Fill rest of the entries in table using optimal substructure property ; eggFloor [ n ] [ k ] holds the result ; Driver program to test to pront printDups
0 | A Naive recursive implementation of 0 - 1 Knapsack problem ; A utility function that returns maximum of two integers ; Returns the maximum value that can be put in a knapsack of capacity W ; Base Case ; If weight of the nth item is more than Knapsack capacity W , then this item cannot be included in the optimal solution ; Return the maximum of two cases : ( 1 ) nth item included ( 2 ) not included ; Driver program to test above function
Longest Increasing Subsequence | DP | A Naive C recursive implementation of LIS problem ; stores the LIS ; To make use of recursive calls , thisfunction must return two things : 1 ) Length of LIS ending with element arr [ n - 1 ] . We use max_ending_here for this purpose2 ) Overall maximum as the LIS may end with an element before arr [ n - 1 ] max_ref is used this purpose . The value of LIS of full array of size n is stored in * max_ref which is our final result ; Base case ; ' max _ ending _ here ' is length of LIS ending with arr [ n - 1 ] ; Recursively get all LIS ending with arr [ 0 ] , arr [ 1 ] ... arr [ n - 2 ] . If arr [ i - 1 ] is smaller than arr [ n - 1 ] , and max ending with arr [ n - 1 ] needs to be updated , then update it ; Compare max_ending_here with the overall max . And update the overall max if needed ; Return length of LIS ending with arr [ n - 1 ] ; The wrapper function for _lis ( ) ; The max variable holds the result ; The function _lis ( ) stores its result in max ; returns max ; Driver program to test above function
Rabin | Following program is a C implementation of Rabin Karp Algorithm given in the CLRS book ; d is the number of characters in the input alphabet ; pat -> pattern txt -> text q -> A prime number ; int p = 0 ; hash value for pattern int t = 0 ; hash value for txt ; The value of h would be " pow ( d , ▁ M - 1 ) % q " ; Calculate the hash value of pattern and first window of text ; Slide the pattern over text one by one ; Check the hash values of current window of text and pattern . If the hash values match then only check for characters on by one ; Check for characters one by one ; if p == t and pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Calculate hash value for next window of text : Remove leading digit , add trailing digit ; We might get negative value of t , converting it to positive ; Driver Code ; A prime number ; function call
The Knight 's tour problem | Backtracking | C program for Knight Tour problem ; A utility function to check if i , j are valid indexes for N * N chessboard ; A utility function to print solution matrix sol [ N ] [ N ] ; This function solves the Knight Tour problem using Backtracking . This function mainly uses solveKTUtil ( ) to solve the problem . It returns false if no complete tour is possible , otherwise return true and prints the tour . Please note that there may be more than one solutions , this function prints one of the feasible solutions . ; Initialization of solution matrix ; xMove [ ] and yMove [ ] define next move of Knight . xMove [ ] is for next value of x coordinate yMove [ ] is for next value of y coordinate ; Since the Knight is initially at the first block ; Start from 0 , 0 and explore all tours using solveKTUtil ( ) ; A recursive utility function to solve Knight Tour problem ; Try all next moves from the current coordinate x , y ; backtracking ; Driver Code ; Function Call
m Coloring Problem | Backtracking |  ; Number of vertices in the graph ; A utility function to print solution ; check if the colored graph is safe or not ; check for every edge ; This function solves the m Coloring problem using recursion . It returns false if the m colours cannot be assigned , otherwise , return true and prints assignments of colours to all vertices . Please note that there may be more than one solutions , this function prints one of the feasible solutions . ; if current index reached end ; if coloring is safe ; Print the solution ; Assign each color from 1 to m ; Recur of the rest vertices ; Driver program to test above function ; Create following graph and test whether it is 3 colorable ( 3 ) -- - ( 2 ) | / | | / | | / | ( 0 ) -- - ( 1 ) ; Number of colors ; Initialize all color values as 0. This initialization is needed correct functioning of isSafe ( )
Logarithm tricks for Competitive Programming | C implementation to find the previous and next power of K ; Function to return the highest power of k less than or equal to n ; Function to return the smallest power of k greater than or equal to n ; Driver Code
Program to find HCF ( Highest Common Factor ) of 2 Numbers | C program to find GCD of two numbers ; Recursive function to return gcd of a and b ; Driver program to test above function
Check whether a number is semiprime or not | C Program to check whether number is semiprime or not ; Utility function to check whether number is semiprime or not ; If number is greater than 1 , add it to the count variable as it indicates the number remain is prime number ; Return '1' if count is equal to '2' else return '0' ; Function to print ' True ' or ' False ' according to condition of semiprime ; Driver code
Reverse Level Order Traversal | A recursive C program to print REVERSE level order traversal ; A binary tree node has data , pointer to left and right child ; Function protoypes ; Function to print REVERSE level order traversal a tree ; Print nodes at a given level ; Compute the " height " of a tree -- the number of nodes along the longest path from the root node down to the farthest leaf node . ; compute the height of each subtree ; use the larger one ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above functions ; Let us create trees shown in above diagram
Indexed Sequential Search | C program for Indexed Sequential Search ; Storing element ; Storing the index ; Driver code ; Element to search ; Function call
Next Smaller Element | Simple C program to print next smaller elements in a given array ; prints element and NSE pair for all elements of arr [ ] of size n ; Driver Code
MSD ( Most Significant Digit ) Radix Sort | C program for the implementation of MSD Radix Sort using counting sort ( ) ; A utility function to print an array ; A utility function to get the digit at index d in a integer ; function to sort array using MSD Radix Sort recursively ; recursion break condition ; temp is created to easily swap strings in arr [ ] ; Store occurrences of most significant character from each integer in count [ ] ; Change count [ ] so that count [ ] now contains actual position of this digits in temp [ ] ; Build the temp ; Copy all integer of temp to arr [ ] , so that arr [ ] now contains partially sorted integers ; Recursively MSD_sort ( ) on each partially sorted integers set to sort them by their next digit ; function find the largest integer ; Main function to call MSD_sort ; Find the maximum number to know number of digits ; get the length of the largest integer ; function call ; Driver Code ; Input array ; Size of the array ; Print the unsorted array ; Function Call ; Print the sorted array
In | Merge In Place in C ; Both sorted sub - arrays must be adjacent in ' a ' ' an ' is the length of the first sorted section in ' a ' ' bn ' is the length of the second sorted section in ' a ' ; Return right now if we 're done ; Do insertion sort to merge if size of sub - arrays are small enough ; p -- ) Insert Sort A into B ; p ++ ) Insert Sort B into A ; Find the pivot points . Basically this is just finding the point in ' a ' where we can swap in the first part of ' b ' such that after the swap the last element in ' a ' will be less than or equal to the least element in ' b ' ; Swap first part of b with last part of a ; Now merge the two sub - array pairings ; } merge_array_inplace ; Merge Sort Implementation ; Sort first and second halves ; Now merge the two sorted sub - arrays together ; Function to print an array ; Driver program to test sort utiliyy
Channel Assignment Problem |  ; A Depth First Search based recursive function that returns true if a matching for vertex u is possible ; Try every receiver one by one ; If sender u has packets to send to receiver v and receiver v is not already mapped to any other sender just check if the number of packets is greater than '0' because only one packet can be sent in a time frame anyways ; Mark v as visited ; If receiver ' v ' is not assigned to any sender OR previously assigned sender for receiver v ( which is matchR [ v ] ) has an alternate receiver available . Since v is marked as visited in the above line , matchR [ v ] in the following recursive call will not get receiver ' v ' again ; Returns maximum number of packets that can be sent parallely in 1 time slot from sender to receiver ; An array to keep track of the receivers assigned to the senders . The value of matchR [ i ] is the sender ID assigned to receiver i . the value - 1 indicates nobody is assigned . ; Initially all receivers are not mapped to any senders ; Count of receivers assigned to senders ; Mark all receivers as not seen for next sender ; Find if the sender ' u ' can be assigned to the receiver ; Driver program to test above function
Decode an Encoded Base 64 String to ASCII String | C Program to decode a base64 Encoded string back to ASCII string ; char_set = " ABCDEFGHIJKLMNOPQRSTUVWXYZ ▁ abcdefghijklmnopqrstuvwxyz0123456789 + / " ; stores the bitstream . ; count_bits stores current number of bits in num . ; selects 4 characters from encoded string at a time . find the position of each encoded character in char_set and stores in num . ; make space for 6 bits . ; encoded [ i + j ] = ' E ' , ' E ' - ' A ' = 5 ' E ' has 5 th position in char_set . ; encoded [ i + j ] = ' e ' , ' e ' - ' a ' = 5 , 5 + 26 = 31 , ' e ' has 31 st position in char_set . ; encoded [ i + j ] = '8' , '8' - '0' = 8 8 + 52 = 60 , '8' has 60 th position in char_set . ; ' + ' occurs in 62 nd position in char_set . ; ' / ' occurs in 63 rd position in char_set . ; ( str [ i + j ] == ' = ' ) remove 2 bits to delete appended bits during encoding . ; 255 in binary is 11111111 ; Driver function ; Do not count last NULL character .
Print list items containing all characters of a given word | C program to print all strings that contain all characters of a word ; prints list items having all characters of word ; Since calloc is used , map [ ] is initialized as 0 ; Set the values in map ; Get the length of given word ; Check each item of list if has all characters of word ; unset the bit so that strings like sss not printed ; Set the values in map for next item ; Driver program to test to pront printDups
Given a string , find its first non | C program to find first non - repeating character ; Returns an array of size 256 containing count of characters in the passed char array ; The function returns index of first non - repeating character in a string . If all characters are repeating then returns - 1 ; To avoid memory leak ; Driver program to test above function
Divide a string in N equal parts | C program to divide a string in n equal parts ; Function to print n equal parts of str ; Check if string can be divided in n equal parts ; Calculate the size of parts to find the division points ; length od string is 28 ; Print 4 equal parts of the string
Program to check if three points are collinear | Slope based solution to check if three points are collinear . ; function to check if point collinear or not ; Driver Code
Represent a given set of points by the best possible straight line | C Program to find m and c for a straight line given , x and y ; function to calculate m and c that best fit points represented by x [ ] and y [ ] ; Driver main function
Minimum insertions to form a palindrome | DP | A Naive recursive program to find minimum number insertions needed to make a string palindrome ; Recursive function to find minimum number of insertions ; Base Cases ; Check if the first and last characters are same . On the basis of the comparison result , decide which subrpoblem ( s ) to call ; Driver program to test above functions
Morris traversal for Preorder | C program for Morris Preorder traversal ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Preorder traversal without recursion and without stack ; If left child is null , print the current node data . Move to right child . ; Find inorder predecessor ; If the right child of inorder predecessor already points to this node ; If right child doesn 't point to this node, then print this  node and make right child point to this node ; Function for sStandard preorder traversal ; Driver program to test above functions
Linked List | Set 2 ( Inserting a node ) | Given a reference ( pointer to pointer ) to the head of a list and an int , inserts a new node on the front of the list . ; 1 & 2 : Allocate the Node & Put in the data ; 3. Make next of new node as head ; 4. move the head to point to the new node
Linked List | Set 2 ( Inserting a node ) | Given a node prev_node , insert a new node after the given prev_node ; 1. check if the given prev_node is NULL ; 2. Allocate the Node & 3. Put in the data ; 4. Make next of new node as next of prev_node ; 5. move the next of prev_node as new_node
Program for n 'th node from the end of a Linked List | 
Detect loop in a linked list | C program to detect loop in a linked list ; Link list node ; allocate node ; put in the data ; link the old list off the new node ; move the head to point to the new node ; Driver program to test above function ; Start with the empty list ; Create a loop for testing
Function to check if a singly linked list is palindrome | Program to check if a linked list is palindrome ; Link list node ; Function to check if given linked list is palindrome or not ; To handle odd size list ; initialize result ; Get the middle of the list . Move slow_ptr by 1 and fast_ptrr by 2 , slow_ptr will have the middle node ; We need previous of the slow_ptr for linked lists with odd elements ; fast_ptr would become NULL when there are even elements in list . And not NULL for odd elements . We need to skip the middle node for odd case and store it somewhere so that we can restore the original list ; Now reverse the second half and compare it with first half ; NULL terminate first half ; Reverse the second half ; compare ; Reverse the second half again ; If there was a mid node ( odd size case ) which was not part of either first half or second half . ; Function to reverse the linked list Note that this function may change the head ; Function to check if two input lists have same data ; Both are empty reurn 1 ; Will reach here when one is NULL and other is not ; Push a node to linked list . Note that this function changes the head ; allocate node ; link the old list off the new node ; move the head to pochar to the new node ; A utility function to print a given linked list ; Drier program to test above function ; Start with the empty list
Swap nodes in a linked list without swapping data | This program swaps the nodes of linked list rather than swapping the field from the nodes . ; Function to swap nodes x and y in linked list by changing links ; Nothing to do if x and y are same ; Search for x ( keep track of prevX and CurrX ; Search for y ( keep track of prevY and CurrY ; If either x or y is not present , nothing to do ; If x is not head of linked list ; Else make y as new head ; If y is not head of linked list ; Else make x as new head ; Swap next pointers ; Function to add a node at the beginning of List ; allocate node and put in the data ; link the old list off the new node ; move the head to point to the new node ; Function to print nodes in a given linked list ; Driver program to test above function ; The constructed linked list is : 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7
Pairwise swap elements of a given linked list | Recursive function to pairwise swap elements of a linked list ; There must be at - least two nodes in the list ; Swap the node 's data with data of next node  ; Call pairWiseSwap ( ) for rest of the list
Sorted insert for circular linked list | Case 2 of the above algo ; swap the data part of head node and new node assuming that we have a function swap ( int * , int * )
Doubly Linked List | Set 1 ( Introduction and Insertion ) | Given a reference ( pointer to pointer ) to the head of a list and an int , inserts a new node on the front of the list . ; 1. allocate node * 2. put in the data ; 3. Make next of new node as head and previous as NULL ; 4. change prev of head node to new node ; 5. move the head to point to the new node
Doubly Linked List | Set 1 ( Introduction and Insertion ) | Given a node as prev_node , insert a new node after the given node ; 1. check if the given prev_node is NULL ; 2. allocate node * 3. put in the data ; 4. Make next of new node as next of prev_node ; 5. Make the next of prev_node as new_node ; 6. Make prev_node as previous of new_node ; 7. Change previous of new_node 's next node 
Doubly Linked List | Set 1 ( Introduction and Insertion ) | Given a reference ( pointer to pointer ) to the head of a DLL and an int , appends a new node at the end ; 1. allocate node 2. put in the data ; 3. This new node is going to be the last node , so make next of it as NULL ; 4. If the Linked List is empty , then make the new node as head ; 5. Else traverse till the last node ; 6. Change the next of last node ; 7. Make last node as previous of new node
Sorted insert in a doubly linked list with head and tail pointers | C program to insetail nodes in doubly linked list such that list remains in ascending order on printing from left to right ; A linked list node ; Function to insetail new node ; If first node to be insetailed in doubly linked list ; If node to be insetailed has value less than first node ; If node to be insetailed has value more than last node ; Find the node before which we need to insert p . ; Insert new node before temp ; Function to print nodes in from left to right ; Driver program to test above functions
Practice questions for Linked List and Recursion | 
Practice questions for Linked List and Recursion | 
Practice questions for Linked List and Recursion | 
Practice questions for Linked List and Recursion |  ; A linked list node ; Prints a linked list in reverse manner ; prints alternate nodes of a Linked List , first from head to end , and then from end to head . ; Given a reference ( pointer to pointer ) to the head of a list and an int , push a new node on the front of the list . ; allocate node ; put in the data ; link the old list off the new node ; move the head to point to the new node ; Driver program to test above functions ; Start with the empty list ; Using push ( ) to construct below list 1 -> 2 -> 3 -> 4 -> 5
Squareroot ( n ) | C program to find sqrt ( n ) 'th node  of a linked list ; Linked list node ; Function to get the sqrt ( n ) th node of a linked list ; Traverse the list ; check if j = sqrt ( i ) ; for first node ; increment j if j = sqrt ( i ) ; return node 's data ; function to add a new node at the beginning of the list ; allocate node ; put in the data ; link the old list off the new node ; move the head to point to the new node ; Driver program to test above function ; Start with the empty list
Find the node with minimum value in a Binary Search Tree |  ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Give a binary search tree and a number , inserts a new node with the given number in the correct place in the tree . Returns the new root pointer which the caller should then use ( the standard trick to avoid using reference parameters ) . ; 1. If the tree is empty , return a new , single node ; 2. Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; Given a non - empty binary search tree , return the minimum data value found in that tree . Note that the entire tree does not need to be searched . ; loop down to find the leftmost leaf ; Driver program to test sameTree function
Construct Tree from given Inorder and Preorder traversals | program to construct tree using inorder and preorder traversals ; A binary tree node has data , pointer to left child and a pointer to right child ; Prototypes for utility functions ; Recursive function to construct binary of size len from Inorder traversal in [ ] and Preorder traversal pre [ ] . Initial values of inStrt and inEnd should be 0 and len - 1. The function doesn 't  do any error checking for cases where inorder and preorder  do not form a tree  ; Pick current node from Preorder traversal using preIndex and increment preIndex ; If this node has no children then return ; Else find the index of this node in Inorder traversal ; Using index in Inorder traversal , construct left and right subtress ; Function to find index of value in arr [ start ... end ] The function assumes that value is present in in [ ] ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; This funtcion is here just to test buildTree ( ) ; first recur on left child ; then print the data of node ; now recur on right child ; Driver program to test above functions ; Let us test the built tree by printing Insorder traversal
Lowest Common Ancestor in a Binary Search Tree . | A recursive C program to find LCA of two nodes n1 and n2 . ; Function to find LCA of n1 and n2 . The function assumes that both n1 and n2 are present in BST ; If both n1 and n2 are smaller than root , then LCA lies in left ; If both n1 and n2 are greater than root , then LCA lies in right ; Helper function that allocates a new node with the given data . ; Driver program to test lca ( ) ; Let us construct the BST shown in the above figure
A program to check if a binary tree is BST or not |  ; false if left is > than node ; false if right is < than node ; false if , recursively , the left or right is not a BST ; passing all that , it 's a BST 
A program to check if a binary tree is BST or not | Returns true if a binary tree is a binary search tree ; false if the max of the left is > than us ; false if the min of the right is <= than us ; false if , recursively , the left or right is not a BST ; passing all that , it 's a BST 
Check if each internal node of a BST has exactly one child | Check if each internal node of BST has only one child ; driver program to test above function
Check if each internal node of a BST has exactly one child | Check if each internal node of BST has only one child ; Initialize min and max using last two elements ; Every element must be either smaller than min or greater than max ; Driver program to test above function
AVL with duplicate keys | C ++ program of AVL tree that handles duplicates ; An AVL tree node ; A utility function to get maximum of two integers ; A utility function to get height of the tree ; A utility function to get maximum of two integers ; Helper function that allocates a new node with the given key and NULL left and right pointers . ; new node is initially added at leaf ; A utility function to right rotate subtree rooted with y See the diagram given above . ; Perform rotation ; Update heights ; Return new root ; A utility function to left rotate subtree rooted with x See the diagram given above . ; Perform rotation ; Update heights ; Return new root ; Get Balance factor of node N ; 1. Perform the normal BST rotation ; If key already exists in BST , increment count and return ; Otherwise , recur down the tree ; 2. Update height of this ancestor node ; 3. Get the balance factor of this ancestor node to check whether this node became unbalanced ; If this node becomes unbalanced , then there are 4 cases Left Left Case ; Right Right Case ; Left Right Case ; Right Left Case ; return the ( unchanged ) node pointer ; Given a non - empty binary search tree , return the node with minimum key value found in that tree . Note that the entire tree does not need to be searched . ; loop down to find the leftmost leaf ; STEP 1 : PERFORM STANDARD BST DELETE ; If the key to be deleted is smaller than the root 's key,  then it lies in left subtree ; If the key to be deleted is greater than the root 's key,  then it lies in right subtree ; if key is same as root 's key, then This is the node  to be deleted ; If key is present more than once , simply decrement count and return ; Else , delete the node node with only one child or no child ; No child case ; One child case ; Copy the contents of the non - empty child ; node with two children : Get the inorder successor ( smallest in the right subtree ) ; Copy the inorder successor 's data to this node and update the count ; Delete the inorder successor ; If the tree had only one node then return ; STEP 2 : UPDATE HEIGHT OF THE CURRENT NODE ; STEP 3 : GET THE BALANCE FACTOR OF THIS NODE ( to check whether this node became unbalanced ) ; If this node becomes unbalanced , then there are 4 cases Left Left Case ; Left Right Case ; Right Right Case ; Right Left Case ; A utility function to print preorder traversal of the tree . The function also prints height of every node ; Driver program to test above function ; Constructing tree given in the above figure
Inorder Successor in Binary Search Tree |  ; A binary tree node has data , the pointer to left child and a pointer to right child ; Give a binary search tree and a number , inserts a new node with the given number in the correct place in the tree . Returns the new root pointer which the caller should then use ( the standard trick to avoid using reference parameters ) . ; 1. If the tree is empty , return a new , single node ; 2. Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; step 1 of the above algorithm ; step 2 of the above algorithm ; Given a non - empty binary search tree , return the minimum data value found in that tree . Note that the entire tree does not need to be searched . ; loop down to find the leftmost leaf ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above functions
Three numbers in a BST that adds upto zero | A C program to check if there is a triplet with sum equal to 0 in a given BST ; A BST node has key , and left and right pointers ; A function to convert given BST to Doubly Linked List . left pointer is used as previous pointer and right pointer is used as next pointer . The function sets * head to point to first and * tail to point to last node of converted DLL ; Base case ; First convert the left subtree ; Then change left of current root as last node of left subtree ; If tail is not NULL , then set right of tail as root , else current node is head ; Update tail ; Finally , convert right subtree ; This function returns true if there is pair in DLL with sum equal to given sum . The algorithm is similar to hasArrayTwoCandidates ( ) tinyurl . com / dy6palr in method 1 of http : ; The main function that returns true if there is a 0 sum triplet in BST otherwise returns false ; Check if the given BST is empty ; Convert given BST to doubly linked list . head and tail store the pointers to first and last nodes in DLLL ; Now iterate through every node and find if there is a pair with sum equal to - 1 * heaf -> key where head is current node ; If there is a pair with sum equal to - 1 * head -> key , then return true else move forward ; If we reach here , then there was no 0 sum triplet ; A utility function to create a new BST node with key as given num ; A utility function to insert a given key to BST ; Driver program to test above functions
Find a pair with given sum in a Balanced BST | In a balanced binary search tree isPairPresent two element which sums to a given value time O ( n ) space O ( logn ) ; A BST node ; Stack type ; A utility function to create a stack of given size ; BASIC OPERATIONS OF STACK ; Returns true if a pair with target sum exists in BST , otherwise false ; Create two stacks . s1 is used for normal inorder traversal and s2 is used for reverse inorder traversal ; Note the sizes of stacks is MAX_SIZE , we can find the tree size and fix stack size as O ( Logn ) for balanced trees like AVL and Red Black tree . We have used MAX_SIZE to keep the code simple done1 , val1 and curr1 are used for normal inorder traversal using s1 done2 , val2 and curr2 are used for reverse inorder traversal using s2 ; The loop will break when we either find a pair or one of the two traversals is complete ; Find next node in normal Inorder traversal . See following post www . geeksforgeeks . org / inorder - tree - traversal - without - recursion / https : ; Find next node in REVERSE Inorder traversal . The only difference between above and below loop is , in below loop right subtree is traversed before left subtree ; If we find a pair , then print the pair and return . The first condition makes sure that two same values are not added ; If sum of current values is smaller , then move to next node in normal inorder traversal ; If sum of current values is greater , then move to next node in reverse inorder traversal ; If any of the inorder traversals is over , then there is no pair so return false ; A utility function to create BST node ; Driver program to test above functions ; 15 / \ 10 20 / \ / \ 8 12 16 25
Left Leaning Red Black Tree ( Insertion ) | C program to implement insert operation in Red Black Tree . ; red == > true , black == > false ; New Node which is created is always red in color . ; utility function to rotate node anticlockwise . ; utility function to rotate node clockwise . ; utility function to check whether node is red in color or not . ; utility function to swap color of two nodes . ; insertion into Left Leaning Red Black Tree . ; Normal insertion code for any Binary Search tree . ; case 1. when right child is Red but left child is Black or doesn 't exist. ; left rotate the node to make it into valid structure . ; swap the colors as the child node should always be red ; case 2 when left child as well as left grand child in Red ; right rotate the current node to make it into a valid structure . ; case 3 when both left and right child are Red in color . ; invert the color of node as well it 's left and right child. ; change the color to black . ; Inorder traversal ; Driver function ; LLRB tree made after all insertions are made . 1. Nodes which have double INCOMING edge means that they are RED in color . 2. Nodes which have single INCOMING edge means that they are BLACK in color . root | 40 \ 20 50 / \ 10 30 25 ; to make sure that root remains black is color ; display the tree through inorder traversal .
Threaded Binary Tree | Utility function to find leftmost node in a tree rooted with n ; C code to do inorder traversal in a threaded binary tree ; If this node is a thread node , then go to inorder successor ; Else go to the leftmost child in right ; subtree
Construct Full Binary Tree from given preorder and postorder traversals | program for construction of full binary tree ; A binary tree node has data , pointer to left child and a pointer to right child ; A utility function to create a node ; A recursive function to construct Full from pre [ ] and post [ ] . preIndex is used to keep track of index in pre [ ] . l is low index and h is high index for the current subarray in post [ ] ; Base case ; The first node in preorder traversal is root . So take the node at preIndex from preorder and make it root , and increment preIndex ; If the current subarry has only one element , no need to recur ; Search the next element of pre [ ] in post [ ] ; Use the index of element found in postorder to divide postorder array in two parts . Left subtree and right subtree ; The main function to construct Full Binary Tree from given preorder and postorder traversals . This function mainly uses constructTreeUtil ( ) ; A utility function to print inorder traversal of a Binary Tree ; Driver program to test above functions
Sorted order printing of a given array that represents a BST | C Code for Sorted order printing of a given array that represents a BST ; print left subtree ; print root ; print right subtree ; driver program to test above function
Floor and Ceil from a BST | Program to find ceil of a given value in BST ; A binary tree node has key , left child and right child ; Helper function that allocates a new node with the given key and NULL left and right pointers . ; Function to find ceil of a given input in BST . If input is more than the max key in BST , return - 1 ; Base case ; We found equal key ; If root 's key is smaller, ceil must be in right subtree ; Else , either left subtree or root has the ceil value ; Driver program to test above function
How to handle duplicates in Binary Search Tree ? | C program to implement basic operations ( search , insert and delete ) on a BST that handles duplicates by storing count with every node ; A utility function to create a new BST node ; A utility function to do inorder traversal of BST ; A utility function to insert a new node with given key in BST ; If the tree is empty , return a new node ; If key already exists in BST , icnrement count and return ; Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; Given a non - empty binary search tree , return the node with minimum key value found in that tree . Note that the entire tree does not need to be searched . ; loop down to find the leftmost leaf ; Given a binary search tree and a key , this function deletes a given key and returns root of modified tree ; base case ; If the key to be deleted is smaller than the root 's key, then it lies in left subtree ; If the key to be deleted is greater than the root 's key,  then it lies in right subtree ; if key is same as root 's key ; If key is present more than once , simply decrement count and return ; ElSE , delete the node node with only one child or no child ; node with two children : Get the inorder successor ( smallest in the right subtree ) ; Copy the inorder successor 's content to this node ; Delete the inorder successor ; Driver Program to test above functions ; Let us create following BST 12 ( 3 ) / \ 10 ( 2 ) 20 ( 1 ) / \ 9 ( 1 ) 11 ( 1 )
How to implement decrease key or change key in Binary Search Tree ? | C program to demonstrate decrease key operation on binary search tree ; A utility function to create a new BST node ; A utility function to do inorder traversal of BST ; A utility function to insert a new node with given key in BST ; If the tree is empty , return a new node ; Otherwise , recur down the tree ; return the ( unchanged ) node pointer ; Given a non - empty binary search tree , return the node with minimum key value found in that tree . Note that the entire tree does not need to be searched . ; loop down to find the leftmost leaf ; Given a binary search tree and a key , this function deletes the key and returns the new root ; base case ; If the key to be deleted is smaller than the root 's key,  then it lies in left subtree ; If the key to be deleted is greater than the root 's key,  then it lies in right subtree ; if key is same as root 's key, then This is the node  to be deleted ; node with only one child or no child ; node with two children : Get the inorder successor ( smallest in the right subtree ) ; Copy the inorder successor 's content to this node ; Delete the inorder successor ; Function to decrease a key value in Binary Search Tree ; First delete old key value ; Then insert new key value ; Return new root ; Driver Program to test above functions ; Let us create following BST 50 / \ 30 70 / \ / \ 20 40 60 80 ; BST is modified to 50 / \ 30 70 / / \ 20 60 80 / 10
Special two digit numbers in a Binary Search Tree | C program to count number of nodes in BST containing two digit special number ; A Tree node ; Function to create a new node ; If the tree is empty , return a new , single node ; Otherwise , recur down the tree ; Function to find if number is special or not ; Check if number is two digit or not ; Function to count number of special two digit number ; Driver program to test ; Function call , to check each node for special two digit number
Construct Special Binary Tree from given Inorder traversal | program to construct tree from inorder traversal ; A binary tree node has data , pointer to left child and a pointer to right child ; Prototypes of a utility function to get the maximum value in inorder [ start . . end ] ; Recursive function to construct binary of size len from Inorder traversal inorder [ ] . Initial values of start and end should be 0 and len - 1. ; Find index of the maximum element from Binary Tree ; Pick the maximum value and make it root ; If this is the only element in inorder [ start . . end ] , then return it ; Using index in Inorder traversal , construct left and right subtress ; Function to find index of the maximum value in arr [ start ... end ] ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; This funtcion is here just to test buildTree ( ) ; first recur on left child ; then print the data of node ; now recur on right child ; Driver program to test above functions ; Assume that inorder traversal of following tree is given 40 / \ 10 30 / \ 5 28 ; Let us test the built tree by printing Insorder traversal
Program for Identity Matrix | C program to print Identity Matrix ; Checking if row is equal to column ; Driver Code
Search in a row wise and column wise sorted matrix | C program to search an element in row - wise and column - wise sorted matrix ; Searches the element x in mat [ ] [ ] . If the element is found , then prints its position and returns true , otherwise prints " not ▁ found " and returns false ; set indexes for top right element ; if mat [ i ] [ j ] < x ; if ( i == n j == - 1 ) ; driver program to test above function
Create a matrix with alternating rectangles of O and X |  ; Function to print alternating rectangles of 0 and X ; k - starting row index m - ending row index l - starting column index n - ending column index i - iterator ; Store given number of rows and columns for later use ; A 2D array to store the output to be printed ; Iniitialize the character to be stoed in a [ ] [ ] ; Fill characters in a [ ] [ ] in spiral form . Every iteration fills one rectangle of either Xs or Os ; Fill the first row from the remaining rows ; Fill the last column from the remaining columns ; Fill the last row from the remaining rows ; Print the first column from the remaining columns ; Flip character for next iteration ; Print the filled matrix ; Driver program to test above functions
Program to Interchange Diagonals of Matrix | C program to interchange the diagonals of matrix ; Function to interchange diagonals ; swap elements of diagonal ; Driver Code
Linked complete binary tree & its creation | Program for linked implementation of complete binary tree ; For Queue Size ; A tree node ; A queue node ; A utility function to create a new tree node ; A utility function to create a new Queue ; Standard Queue Functions ; A utility function to check if a tree node has both left and right children ; Function to insert a new node in complete binary tree ; Create a new node for given data ; If the tree is empty , initialize the root with new node . ; get the front node of the queue . ; If the left child of this front node doesn t exist , set the left child as the new node ; If the right child of this front node doesn t exist , set the right child as the new node ; If the front node has both the left child and right child , Dequeue ( ) it . ; Enqueue ( ) the new node for later insertions ; Standard level order traversal to test above function ; Driver program to test above functions
Convert a given Binary Tree to Doubly Linked List | Set 1 | A C program for in - place conversion of Binary Tree to DLL ; A binary tree node has data , and left and right pointers ; This is the core function to convert Tree to list . This function follows steps 1 and 2 of the above algorithm ; Base case ; Convert the left subtree and link to root ; Convert the left subtree ; Find inorder predecessor . After this loop , left will point to the inorder predecessor ; Make root as next of the predecessor ; Make predecssor as previous of root ; Convert the right subtree and link to root ; Convert the right subtree ; Find inorder successor . After this loop , right will point to the inorder successor ; Make root as previous of successor ; Make successor as next of root ; The main function that first calls bintree2listUtil ( ) , then follows step 3 of the above algorithm ; Base case ; Convert to DLL using bintree2listUtil ( ) ; bintree2listUtil ( ) returns root node of the converted DLL . We need pointer to the leftmost node which is head of the constructed DLL , so move to the leftmost node ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Function to print nodes in a given doubly linked list ; Driver program to test above functions ; Let us create the tree shown in above diagram ; Convert to DLL ; Print the converted list
Print unique rows in a given boolean matrix | Given a binary matrix of M X N of integers , you need to return only unique rows of binary array ; A Trie node ; Only two children needed for 0 and 1 ; A utility function to allocate memory for a new Trie node ; Inserts a new matrix row to Trie . If row is already present , then returns 0 , otherwise insets the row and return 1 ; base case ; Recur if there are more entries in this row ; If all entries of this row are processed ; unique row found , return 1 ; duplicate row found , return 0 ; A utility function to print a row ; The main function that prints all unique rows in a given matrix . ; create an empty Trie ; Iterate through all rows ; insert row to TRIE ; unique row found , print it ; Driver program to test above functions
Find a common element in all rows of a given row | A C program to find a common element in all rows of a row wise sorted array ; Specify number of rows and columns ; Returns common element in all rows of mat [ M ] [ N ] . If there is no common element , then - 1 is returned ; An array to store indexes of current last column ; To store index of row whose current last element is minimum ; Initialize current last element of all rows ; Initialize min_row as first row ; Keep finding min_row in current last column , till either all elements of last column become same or we hit first column . ; Find minimum in current last column ; eq_count is count of elements equal to minimum in current last column . ; Traverse current last column elements again to update it ; Decrease last column index of a row whose value is more than minimum . ; Reduce last column index by 1 ; If equal count becomes M , return the value ; driver program to test above function
Convert a given Binary Tree to Doubly Linked List | Set 2 | A simple inorder traversal based program to convert a Binary Tree to DLL ; A tree node ; A utility function to create a new tree node ; Standard Inorder traversal of tree ; Changes left pointers to work as previous pointers in converted DLL The function simply does inorder traversal of Binary Tree and updates left pointer using previously visited node ; Changes right pointers to work as next pointers in converted DLL ; Find the right most node in BT or last node in DLL ; Start from the rightmost node , traverse back using left pointers . While traversing , change right pointer of nodes . ; The leftmost node is head of linked list , return it ; The main function that converts BST to DLL and returns head of DLL ; Set the previous pointer ; Set the next pointer and return head of DLL ; Traverses the DLL from left tor right ; Driver program to test above functions ; Let us create the tree shown in above diagram
Convert an arbitrary Binary Tree to a tree that holds Children Sum Property | Program to convert an aribitary binary tree to a tree that holds children sum property ; A binary tree node ; This function is used to increment left subtree ; This function changes a tree to hold children sum property ; If tree is empty or it 's a leaf node then  return true  ; convert left and right subtrees ; If left child is not present then 0 is used as data of left child ; If right child is not present then 0 is used as data of right child ; get the diff of node 's data and children sum  ; If node ' s ▁ children ▁ sum ▁ is ▁ greater ▁ than ▁ the ▁ node ' s data ; THIS IS TRICKY -- > If node 's data is greater than children sum,  then increment subtree by diff  ; - diff is used to make diff positive ; This function is used to increment subtree by diff ; IF left child is not NULL then increment it ; Recursively call to fix the descendants of node -> left ; Else increment right child ; Recursively call to fix the descendants of node -> right ; Given a binary tree , printInorder ( ) prints out its inorder traversal ; first recur on left child ; then print the data of node ; now recur on right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above functions
Convert a given tree to its Sum Tree |  ; A tree node structure ; Convert a given tree to a tree where every node contains sum of values of nodes in left and right subtrees in the original tree ; Base case ; Store the old value ; Recursively call for left and right subtrees and store the sum as new value of this node ; Return the sum of values of nodes in left and right subtrees and old_value of this node ; A utility function to print inorder traversal of a Binary Tree ; Utility function to create a new Binary Tree node ; Driver function to test above functions ; Constructing tree given in the above figure ; Print inorder traversal of the converted tree to test result of toSumTree ( )
Find a peak element | C program to find a peak element using divide and conquer ; A binary search based function that returns index of a peak element ; Find index of middle element ( low + high ) / 2 ; Compare middle element with its neighbours ( if neighbours exist ) ; If middle element is not peak and its left neighbour is greater than it , then left half must have a peak element ; If middle element is not peak and its right neighbour is greater than it , then right half must have a peak element ; A wrapper over recursive function findPeakUtil ( ) ; Driver program to check above functions
Find the two repeating elements in a given array |  ; Print Repeating function ; Driver Code
Find the two repeating elements in a given array |  ; Function ; Driver code
Find the two repeating elements in a given array |  ; printRepeating function ; S is for sum of elements in arr [ ] ; P is for product of elements in arr [ ] ; x and y are two repeating elements ; D is for difference of x and y , i . e . , x - y ; Calculate Sum and Product of all elements in arr [ ] ; S is x + y now ; P is x * y now ; D is x - y now ; factorial of n ; driver code
Find the two repeating elements in a given array | C code to Find the two repeating elements in a given array ; Will hold xor of all elements ; Will have only single set bit of xor ; Get the xor of all elements in arr [ ] and { 1 , 2 . . n } ; Get the rightmost set bit in set_bit_no ; Now divide elements in two sets by comparing rightmost set bit of xor with bit at same position in each element . ; XOR of first set in arr [ ] ; XOR of second set in arr [ ] ; XOR of first set in arr [ ] and { 1 , 2 , ... n } ; XOR of second set in arr [ ] and { 1 , 2 , ... n } ; driver code
Find the two repeating elements in a given array |  ; Function to print repeating ; Driver code
Find subarray with given sum | Set 1 ( Nonnegative Numbers ) | A simple program to print subarray with sum as given sum ; Returns true if the there is a subarray of arr [ ] with a sum equal to ' sum ' otherwise returns false . Also , prints the result ; Pick a starting point ; try all subarrays starting with ' i ' ; Driver program to test above function
Find subarray with given sum | Set 1 ( Nonnegative Numbers ) | An efficient program to print subarray with sum as given sum ; Returns true if the there is a subarray of arr [ ] with a sum equal to ' sum ' otherwise returns false . Also , prints the result ; Initialize curr_sum as value of first element and starting point as 0 ; Add elements one by one to curr_sum and if the curr_sum exceeds the sum , then remove starting element ; If curr_sum exceeds the sum , then remove the starting elements ; If curr_sum becomes equal to sum , then return true ; Add this element to curr_sum ; If we reach here , then no subarray ; Driver program to test above function
Find a triplet that sum to a given value |  ; returns true if there is triplet with sum equal to ' sum ' present in A [ ] . Also , prints the triplet ; Fix the first element as A [ i ] ; Fix the second element as A [ j ] ; Now look for the third number ; If we reach here , then no triplet was found ; Driver program to test above function
Analysis of Algorithms | Set 2 ( Worst , Average and Best Cases ) | C implementation of the approach ; Linearly search x in arr [ ] . If x is present then return the index , otherwise return - 1 ; Driver program to test above functions
Binary Search | C program to implement recursive Binary Search ; A recursive binary search function . It returns location of x in given array arr [ l . . r ] is present , otherwise - 1 ; If the element is present at the middle itself ; If element is smaller than mid , then it can only be present in left subarray ; Else the element can only be present in right subarray ; We reach here when element is not present in array ; Driver method to test above
Binary Search | C program to implement iterative Binary Search ; A iterative binary search function . It returns location of x in given array arr [ l . . r ] if present , otherwise - 1 ; Check if x is present at mid ; If x greater , ignore left half ; If x is smaller , ignore right half ; if we reach here , then element was not present ; Driver method to test above
Interpolation Search | C program to implement interpolation search with recursion ; If x is present in arr [ 0. . n - 1 ] , then returns index of it , else returns - 1. ; Since array is sorted , an element present in array must be in range defined by corner ; Probing the position with keeping uniform distribution in mind . ; Condition of target found ; If x is larger , x is in right sub array ; If x is smaller , x is in left sub array ; Driver Code ; Array of items on which search will be conducted . ; Element to be searched ; If element was found
Merge Sort | C program for Merge Sort ; Merges two subarrays of arr [ ] . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ] ; Find sizes of two subarrays to be merged ; create temp arrays ; Copy data to temp arrays L [ ] and R [ ] ; Merge the temp arrays Initial indexes of first and second subarrays ; Initial index of merged subarray ; Copy the remaining elements of L [ ] , if there are any ; Copy the remaining elements of R [ ] , if there are any ; l is for left index and r is right index of the sub - array of arr to be sorted ; Same as ( l + r ) / 2 , but avoids overflow for large l and h ; Sort first and second halves ; Merge the sorted halves ; Function to print an array ; Driver code
Iterative Quick Sort | An iterative implementation of quick sort ; A utility function to swap two elements ; This function is same in both iterative and recursive ; A [ ] -- > Array to be sorted , l -- > Starting index , h -- > Ending index ; Create an auxiliary stack ; initialize top of stack ; push initial values of l and h to stack ; Keep popping from stack while is not empty ; Pop h and l ; Set pivot element at its correct position in sorted array ; If there are elements on left side of pivot , then push left side to stack ; If there are elements on right side of pivot , then push right side to stack ; A utility function to print contents of arr ; Driver program to test above functions ; Function calling
Activity Selection Problem | Greedy Algo | C program for activity selection problem . The following implementation assumes that the activities are already sorted according to their finish time ; Prints a maximum set of activities that can be done by a single person , one at a time . n -- > Total number of activities s [ ] -- > An array that contains start time of all activities f [ ] -- > An array that contains finish time of all activities ; The first activity always gets selected ; Consider rest of the activities ; If this activity has start time greater than or equal to the finish time of previously selected activity , then select it ; driver program to test above function
Efficient Huffman Coding for Sorted Input | Greedy Algo | C Program for Efficient Huffman Coding for Sorted input ; This constant can be avoided by explicitly calculating height of Huffman Tree ; A node of huffman tree ; Structure for Queue : collection of Huffman Tree nodes ( orQueueNodes ) ; A utility function to create a new Queuenode ; A utility function to create a Queue of given capacity ; A utility function to check if size of given queue is 1 ; A utility function to check if given queue is empty ; A utility function to check if given queue is full ; A utility function to add an item to queue ; A utility function to remove an item from queue ; If there is only one item in queue ; A utility function to get from of queue ; A function to get minimum item from two queues ; Step 3. a : If first queue is empty , dequeue from second queue ; Step 3. b : If second queue is empty , dequeue from first queue ; Step 3. c : Else , compare the front of two queues and dequeue minimum ; Utility function to check if this node is leaf ; A utility function to print an array of size n ; The main function that builds Huffman tree ; Step 1 : Create two empty queues ; Step 2 : Create a leaf node for each unique character and Enqueue it to the first queue in non - decreasing order of frequency . Initially second queue is empty ; Run while Queues contain more than one node . Finally , first queue will be empty and second queue will contain only one node ; Step 3 : Dequeue two nodes with the minimum frequency by examining the front of both queues ; Step 4 : Create a new internal node with frequency equal to the sum of the two nodes frequencies . Enqueue this node to second queue . ; Prints huffman codes from the root of Huffman Tree . It uses arr [ ] to store codes ; Assign 0 to left edge and recur ; Assign 1 to right edge and recur ; If this is a leaf node , then it contains one of the input characters , print the character and its code from arr [ ] ; The main function that builds a Huffman Tree and print codes by traversing the built Huffman Tree ; Construct Huffman Tree ; Print Huffman codes using the Huffman tree built above ; Driver program to test above functions
Longest Common Subsequence | DP | A Naive recursive implementation of LCS problem ; Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Utility function to get max of 2 integers ; Driver program to test above function
Longest Common Subsequence | DP | Dynamic Programming C implementation of LCS problem ; Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains length of LCS of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] ; L [ m ] [ n ] contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] ; Utility function to get max of 2 integers ; Driver program to test above function
Min Cost Path | DP | A Naive recursive implementation of MCP ( Minimum Cost Path ) problem ; A utility function that returns minimum of 3 integers ; Returns cost of minimum cost path from ( 0 , 0 ) to ( m , n ) in mat [ R ] [ C ] ; Driver program to test above functions
Min Cost Path | DP | Dynamic Programming implementation of MCP problem ; Instead of following line , we can use int tc [ m + 1 ] [ n + 1 ] or dynamically allocate memory to save space . The following line is used to keep the program simple and make it working on all compilers . ; Initialize first column of total cost ( tc ) array ; Initialize first row of tc array ; Construct rest of the tc array ; A utility function that returns minimum of 3 integers ; Driver program to test above functions
0 | A Naive recursive implementation of 0 - 1 Knapsack problem ; A utility function that returns maximum of two integers ; Returns the maximum value that can be put in a knapsack of capacity W ; Base Case ; If weight of the nth item is more than Knapsack capacity W , then this item cannot be included in the optimal solution ; Return the maximum of two cases : ( 1 ) nth item included ( 2 ) not included ; Driver program to test above function
0 | A Dynamic Programming based solution for 0 - 1 Knapsack problem ; A utility function that returns maximum of two integers ; Returns the maximum value that can be put in a knapsack of capacity W ; Build table K [ ] [ ] in bottom up manner ; Driver Code
Egg Dropping Puzzle | DP |  ; A utility function to get maximum of two integers ; Function to get minimum number of trials needed in worst case with n eggs and k floors ; If there are no floors , then no trials needed . OR if there is one floor , one trial needed . ; We need k trials for one egg and k floors ; Consider all droppings from 1 st floor to kth floor and return the minimum of these values plus 1. ; Driver program to test to pront printDups
Longest Palindromic Subsequence | DP | C program of above approach ; A utility function to get max of two integers ; Returns the length of the longest palindromic subsequence in seq ; Base Case 1 : If there is only 1 character ; Base Case 2 : If there are only 2 characters and both are same ; If the first and last characters match ; If the first and last characters do not match ; Driver program to test above functions
Word Wrap Problem | DP | A Dynamic programming solution for Word Wrap Problem ; A utility function to print the solution ; l [ ] represents lengths of different words in input sequence . For example , l [ ] = { 3 , 2 , 2 , 5 } is for a sentence like " aaa ▁ bb ▁ cc ▁ ddddd " . n is size of l [ ] and M is line width ( maximum no . of characters that can fit in a line ) ; For simplicity , 1 extra space is used in all below arrays extras [ i ] [ j ] will have number of extra spaces if words from i to j are put in a single line ; lc [ i ] [ j ] will have cost of a line which has words from i to j ; c [ i ] will have total cost of optimal arrangement of words from 1 to i ; p [ ] is used to print the solution . ; calculate extra spaces in a single line . The value extra [ i ] [ j ] indicates extra spaces if words from word number i to j are placed in a single line ; Calculate line cost corresponding to the above calculated extra spaces . The value lc [ i ] [ j ] indicates cost of putting words from word number i to j in a single line ; Calculate minimum cost and find minimum cost arrangement . The value c [ j ] indicates optimized cost to arrange words from word number 1 to j . ; Driver program to test above functions
Optimal Binary Search Tree | DP | A naive recursive implementation of optimal binary search tree problem ; A utility function to get sum of array elements freq [ i ] to freq [ j ] ; A recursive function to calculate cost of optimal binary search tree ; Base cases no elements in this subarray ; one element in this subarray ; Get sum of freq [ i ] , freq [ i + 1 ] , ... freq [ j ] ; Initialize minimum value ; One by one consider all elements as root and recursively find cost of the BST , compare the cost with min and update min if needed ; Return minimum value ; The main function that calculates minimum cost of a Binary Search Tree . It mainly uses optCost ( ) to find the optimal cost . ; Here array keys [ ] is assumed to be sorted in increasing order . If keys [ ] is not sorted , then add code to sort keys , and rearrange freq [ ] accordingly . ; Driver program to test above functions
Optimal Binary Search Tree | DP | Dynamic Programming code for Optimal Binary Search Tree Problem ; A utility function to get sum of array elements freq [ i ] to freq [ j ] ; A Dynamic Programming based function that calculates minimum cost of a Binary Search Tree . ; Create an auxiliary 2D matrix to store results of subproblems ; For a single key , cost is equal to frequency of the key ; Now we need to consider chains of length 2 , 3 , ... . L is chain length . ; i is row number in cost [ ] [ ] ; Get column number j from row number i and chain length L ; Try making all keys in interval keys [ i . . j ] as root ; c = cost when keys [ r ] becomes root of this subtree ; Driver program to test above functions
Largest Independent Set Problem | DP | A naive recursive implementation of Largest Independent Set problem ; A utility function to find max of two integers ; A binary tree node has data , pointer to left child and a pointer to right child ; The function returns size of the largest independent set in a given binary tree ; Caculate size excluding the current node ; Calculate size including the current node ; Return the maximum of two sizes ; A utility function to create a node ; Driver program to test above functions ; Let us construct the tree given in the above diagram
Mobile Numeric Keypad Problem | A Space Optimized C program to count number of possible numbers of given length ; Return count of all possible numbers of length n in a given numeric keyboard ; odd [ i ] , even [ i ] arrays represent count of numbers starting with digit i for any length j ; for j = 1 ; Bottom Up calculation from j = 2 to n ; Here we are explicitly writing lines for each number 0 to 9. But it can always be written as DFS on 4 X3 grid using row , column array valid moves ; Get count of all possible numbers of length " n " starting with digit 0 , 1 , 2 , ... , 9 ; Driver program to test above function
Vertex Cover Problem | Set 2 ( Dynamic Programming Solution for Tree ) | Dynamic programming based program for Vertex Cover problem for a Binary Tree ; A utility function to find min of two integers ; A binary tree node has data , pointer to left child and a pointer to right child ; A memoization based function that returns size of the minimum vertex cover . ; The size of minimum vertex cover is zero if tree is empty or there is only one node ; If vertex cover for this node is already evaluated , then return it to save recomputation of same subproblem again . ; Calculate size of vertex cover when root is part of it ; Calculate size of vertex cover when root is not part of it ; Minimum of two values is vertex cover , store it before returning ; A utility function to create a node ; Set the vertex cover as 0 ; Driver program to test above functions ; Let us construct the tree given in the above diagram
Count number of ways to reach a given score in a game | A C program to count number of possible ways to a given score can be reached in a game where a move can earn 3 or 5 or 10 ; Returns number of ways to reach score n ; table [ i ] will store count of solutions for value i . ; Initialize all table values as 0 ; Base case ( If given value is 0 ) ; One by one consider given 3 moves and update the table [ ] values after the index greater than or equal to the value of the picked move ; Driver program
Naive algorithm for Pattern Searching | C program for Naive Pattern Searching algorithm ; A loop to slide pat [ ] one by one ; For current index i , check for pattern match ; if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Driver program to test above function
Rabin | Following program is a C implementation of Rabin Karp Algorithm given in the CLRS book ; d is the number of characters in the input alphabet ; pat -> pattern txt -> text q -> A prime number ; hash value for pattern ; hash value for txt ; The value of h would be " pow ( d , ▁ M - 1 ) % q " ; Calculate the hash value of pattern and first window of text ; Slide the pattern over text one by one ; Check the hash values of current window of text and pattern . If the hash values match then only check for characters on by one ; Check for characters one by one ; if p == t and pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Calculate hash value for next window of text : Remove leading digit , add trailing digit ; We might get negative value of t , converting it to positive ; Driver Code ; A prime number ; function call
Optimized Naive Algorithm for Pattern Searching | C program for A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different ; A modified Naive Pettern Searching algorithn that is optimized for the cases when all characters of pattern are different ; For current index i , check for pattern match ; if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; slide the pattern by j ; Driver program to test above function
Finite Automata algorithm for Pattern Searching | C program for Finite Automata Pattern searching Algorithm ; If the character c is same as next character in pattern , then simply increment state ; ns stores the result which is next state ; ns finally contains the longest prefix which is also suffix in " pat [ 0 . . state - 1 ] c " Start from the largest possible value and stop when you find a prefix which is also suffix ; This function builds the TF table which represents4 Finite Automata for a given pattern ; Prints all occurrences of pat in txt ; Process txt over FA . ; Driver program to test above function
Boyer Moore Algorithm for Pattern Searching | C Program for Bad Character Heuristic of Boyer Moore String Matching Algorithm ; A utility function to get maximum of two integers ; The preprocessing function for Boyer Moore 's bad character heuristic ; Initialize all occurrences as - 1 ; Fill the actual value of last occurrence of a character ; A pattern searching function that uses Bad Character Heuristic of Boyer Moore Algorithm ; Fill the bad character array by calling the preprocessing function badCharHeuristic ( ) for given pattern ; s is shift of the pattern with respect to text ; there are n - m + 1 potential allignments ; Keep reducing index j of pattern while characters of pattern and text are matching at this shift s ; If the pattern is present at current shift , then index j will become - 1 after the above loop ; Shift the pattern so that the next character in text aligns with the last occurrence of it in pattern . The condition s + m < n is necessary for the case when pattern occurs at the end of text ; Shift the pattern so that the bad character in text aligns with the last occurrence of it in pattern . The max function is used to make sure that we get a positive shift . We may get a negative shift if the last occurrence of bad character in pattern is on the right side of the current character . ; Driver program to test above function
Subset Sum | Backtracking |  ; prints subset found ; inputs s - set vector t - tuplet vector s_size - set size t_size - tuplet size so far sum - sum so far ite - nodes count target_sum - sum to be found ; We found subset ; Exclude previously added item and consider next candidate ; generate nodes along the breadth ; consider next level node ( along depth ) ; Wrapper to print subsets that sum to target_sum input is weights vector and target_sum ; Driver Code
Subset Sum | Backtracking |  ; prints subset found ; qsort compare function ; inputs s - set vector t - tuplet vector s_size - set size t_size - tuplet size so far sum - sum so far ite - nodes count target_sum - sum to be found ; We found sum ; constraint check ; Exclude previous added item and consider next candidate ; constraint check ; generate nodes along the breadth ; consider next level node ( along depth ) ; Wrapper that prints subsets that sum to target_sum ; sort the set ; Driver code
Sudoku | Backtracking |  ; N is the size of the 2D matrix N * N ; A utility function to print grid ; Checks whether it will be legal to assign num to the given row , col ; Check if we find the same num in the similar row , we return 0 ; Check if we find the same num in the similar column , we return 0 ; Check if we find the same num in the particular 3 * 3 matrix , we return 0 ; Takes a partially filled - in grid and attempts to assign values to all unassigned locations in such a way to meet the requirements for Sudoku solution ( non - duplication across rows , columns , and boxes ) ; Check if we have reached the 8 th row and 9 th column ( 0 indexed matrix ) , we are returning true to avoid further backtracking ; Check if column value becomes 9 , we move to next row and column start from 0 ; Check if the current position of the grid already contains value > 0 , we iterate for next column ; Check if it is safe to place the num ( 1 - 9 ) in the given row , col -> we move to next column ; assigning the num in the current ( row , col ) position of the grid and assuming our assined num in the position is correct ; Checking for next possibility with next column ; Removing the assigned num , since our assumption was wrong , and we go for next assumption with diff num value ; Driver code
Median of two sorted arrays of same size | A Simple Merge based O ( n ) solution to find median of two sorted arrays ; This function returns median of ar1 [ ] and ar2 [ ] . Assumptions in this function : Both ar1 [ ] and ar2 [ ] are sorted arrays Both have n elements ; Since there are 2 n elements , median will be average of elements at index n - 1 and n in the array obtained after merging ar1 and ar2 ; Below is to handle case where all elements of ar1 [ ] are smaller than smallest ( or first ) element of ar2 [ ] ; Below is to handle case where all elements of ar2 [ ] are smaller than smallest ( or first ) element of ar1 [ ] ; equals sign because if two arrays have some common elements ; Store the prev median ; Store the prev median ; Driver program to test above function
Median of two sorted arrays of same size | A divide and conquer based efficient solution to find median of two sorted arrays of same size . ; to get median of a sorted array ; This function returns median of ar1 [ ] and ar2 [ ] . Assumptions in this function : Both ar1 [ ] and ar2 [ ] are sorted arrays Both have n elements ; get the median of the first array ; get the median of the second array ; If medians are equal then return either m1 or m2 ; if m1 < m2 then median must exist in ar1 [ m1 ... . ] and ar2 [ ... . m2 ] ; if m1 > m2 then median must exist in ar1 [ ... . m1 ] and ar2 [ m2 ... ] ; Function to get median of a sorted array ; Driver program to test above function
Closest Pair of Points using Divide and Conquer algorithm | A divide and conquer program in C / C ++ to find the smallest distance from a given set of points . ; A structure to represent a Point in 2D plane ; Needed to sort array of points according to X coordinate ; Needed to sort array of points according to Y coordinate ; A utility function to find the distance between two points ; A Brute Force method to return the smallest distance between two points in P [ ] of size n ; A utility function to find a minimum of two float values ; A utility function to find the distance between the closest points of strip of a given size . All points in strip [ ] are sorted according to y coordinate . They all have an upper bound on minimum distance as d . Note that this method seems to be a O ( n ^ 2 ) method , but it 's a O(n) method as the inner loop runs at most 6 times ; Initialize the minimum distance as d ; Pick all points one by one and try the next points till the difference between y coordinates is smaller than d . This is a proven fact that this loop runs at most 6 times ; A recursive function to find the smallest distance . The array P contains all points sorted according to x coordinate ; If there are 2 or 3 points , then use brute force ; Find the middle point ; Consider the vertical line passing through the middle point calculate the smallest distance dl on left of middle point and dr on right side ; Find the smaller of two distances ; Build an array strip [ ] that contains points close ( closer than d ) to the line passing through the middle point ; Find the closest points in strip . Return the minimum of d and closest distance is strip [ ] ; The main function that finds the smallest distance This method mainly uses closestUtil ( ) ; Use recursive function closestUtil ( ) to find the smallest distance ; Driver program to test above functions
Lucky Numbers |  ; Returns 1 if n is a lucky no . ohterwise returns 0 ; variable next_position is just for readability of the program we can remove it and use n only ; calculate next position of input no ; Driver function to test above function
Write you own Power without using multiplication ( * ) and division ( / ) operators |  ; Works only if a >= 0 and b >= 0 ; driver program to test above function
Write you own Power without using multiplication ( * ) and division ( / ) operators |  ; A recursive function to get x * y ; A recursive function to get a ^ b Works only if a >= 0 and b >= 0 ; driver program to test above functions
Count numbers that don 't contain 3 |  ; returns count of numbers which are in range from 1 to n and don 't contain 3  as a digit  ; Base cases ( Assuming n is not negative ) ; Calculate 10 ^ ( d - 1 ) ( 10 raise to the power d - 1 ) where d is number of digits in n . po will be 100 for n = 578 ; find the most significant digit ( msd is 5 for 578 ) ; For 578 , total will be 4 * count ( 10 ^ 2 - 1 ) + 4 + count ( 78 ) ; For 35 , total will be equal to count ( 29 ) ; Driver program to test above function
Lexicographic rank of a string | C program to find lexicographic rank of a string ; A utility function to find factorial of n ; A utility function to count smaller characters on right of arr [ low ] ; A function to find rank of a string in all permutations of characters ; count number of chars smaller than str [ i ] fron str [ i + 1 ] to str [ len - 1 ] ; Driver program to test above function
Lexicographic rank of a string | A O ( n ) solution for finding rank of string ; all elements of count [ ] are initialized with 0 ; A utility function to find factorial of n ; Construct a count array where value at every index contains count of smaller characters in whole string ; Removes a character ch from count [ ] array constructed by populateAndIncreaseCount ( ) ; A function to find rank of a string in all permutations of characters ; Populate the count array such that count [ i ] contains count of characters which are present in str and are smaller than i ; count number of chars smaller than str [ i ] fron str [ i + 1 ] to str [ len - 1 ] ; Reduce count of characters greater than str [ i ] ; Driver program to test above function
Print all permutations in sorted ( lexicographic ) order | Program to print all permutations of a string in sorted order . ; Following function is needed for library function qsort ( ) . Refer http : www . cplusplus . com / reference / clibrary / cstdlib / qsort / ; A utility function two swap two characters a and b ; This function finds the index of the smallest character which is greater than ' first ' and is present in str [ l . . h ] ; initialize index of ceiling element ; Now iterate through rest of the elements and find the smallest character greater than ' first ' ; Print all permutations of str in sorted order ; Get size of string ; Sort the string in increasing order ; Print permutations one by one ; print this permutation ; Find the rightmost character which is smaller than its next character . Let us call it ' first ▁ char ' ; If there is no such character , all are sorted in decreasing order , means we just printed the last permutation and we are done . ; Find the ceil of ' first ▁ char ' in right of first character . Ceil of a character is the smallest character greater than it ; Swap first and second characters ; Sort the string on right of ' first ▁ char ' ; Driver program to test above function
Print all permutations in sorted ( lexicographic ) order | An optimized version that uses reverse instead of sort for finding the next permutation A utility function to reverse a string str [ l . . h ] ;  ;  ; Print all permutations of str in sorted order ; Get size of string ; Sort the string in increasing order ; Print permutations one by one ; print this permutation ; Find the rightmost character which is smaller than its next character . Let us call it ' first ▁ char ' ; If there is no such character , all are sorted in decreasing order , means we just printed the last permutation and we are done . ; Find the ceil of ' first ▁ char ' in right of first character . Ceil of a character is the smallest character greater than it ; Swap first and second characters ; reverse the string on right of ' first ▁ char '
Efficient program to calculate e ^ x | C Efficient program to calculate e raise to the power x ; Returns approximate value of e ^ x using sum of first n terms of Taylor Series ; initialize sum of series ; Driver program to test above function
Random number generator in arbitrary probability distribution fashion | C program to generate random numbers according to given frequency distribution ; Utility function to find ceiling of r in arr [ l . . h ] ; Same as mid = ( l + h ) / 2 ; The main function that returns a random number from arr [ ] according to distribution array defined by freq [ ] . n is size of arrays . ; Create and fill prefix array ; prefix [ n - 1 ] is sum of all frequencies . Generate a random number with value from 1 to this sum ; Find index of ceiling of r in prefix arrat ; Driver program to test above functions ; Use a different seed value for every run . ; Let us generate 10 random numbers accroding to given distribution
Write a function that generates one of 3 numbers according to given probabilities | This function generates ' x ' with probability px / 100 , ' y ' with probability py / 100 and ' z ' with probability pz / 100 : Assumption : px + py + pz = 100 where px , py and pz lie between 0 to 100 ; Generate a number from 1 to 100 ; r is smaller than px with probability px / 100 ; r is greater than px and smaller than or equal to px + py with probability py / 100 ; r is greater than px + py and smaller than or equal to 100 with probability pz / 100
Calculate the angle between hour hand and minute hand | C program to find angle between hour and minute hands ; Utility function to find minimum of two integers ; Function to calculate the angle ; validate the input ; Calculate the angles moved by hour and minute hands with reference to 12 : 00 ; Find the difference between two angles ; Return the smaller angle of two possible angles ; Driver Code
Find the element that appears once | C program to find the element that occur only once ; Method to find the element that occur only once ; The expression " one ▁ & ▁ arr [ i ] " gives the bits that are there in both ' ones ' and new element from arr [ ] . We add these bits to ' twos ' using bitwise OR Value of ' twos ' will be set as 0 , 3 , 3 and 1 after 1 st , 2 nd , 3 rd and 4 th iterations respectively ; XOR the new bits with previous ' ones ' to get all bits appearing odd number of times Value of ' ones ' will be set as 3 , 0 , 2 and 3 after 1 st , 2 nd , 3 rd and 4 th iterations respectively ; The common bits are those bits which appear third time So these bits should not be there in both ' ones ' and ' twos ' . common_bit_mask contains all these bits as 0 , so that the bits can be removed from ' ones ' and ' twos ' Value of ' common _ bit _ mask ' will be set as 00 , 00 , 01 and 10 after 1 st , 2 nd , 3 rd and 4 th iterations respectively ; Remove common bits ( the bits that appear third time ) from ' ones ' Value of ' ones ' will be set as 3 , 0 , 0 and 2 after 1 st , 2 nd , 3 rd and 4 th iterations respectively ; Remove common bits ( the bits that appear third time ) from ' twos ' Value of ' twos ' will be set as 0 , 3 , 1 and 0 after 1 st , 2 nd , 3 rd and 4 th itearations respectively ; Driver Code
Find the element that appears once | C program to find the element that occur only once ; Initialize result ; Iterate through every bit ; Find sum of set bits at ith position in all array elements ; The bits with sum not multiple of 3 , are the bits of element with single occurrence . ; Driver program to test above function
Count total set bits in all numbers from 1 to n | A O ( Logn ) complexity program to count set bits in all numbers from 1 to n ; Returns position of leftmost set bit . The rightmost position is considered as 0 ; Given the position of previous leftmost set bit in n ( or an upper bound on leftmost position ) returns the new position of leftmost set bit in n ; The main recursive function used by countSetBits ( ) ; Get the position of leftmost set bit in n . This will be used as an upper bound for next set bit function ; Use the position ; Base Case : if n is 0 , then set bit count is 0 ; get position of next leftmost set bit ; If n is of the form 2 ^ x - 1 , i . e . , if n is like 1 , 3 , 7 , 15 , 31 , . . etc , then we are done . Since positions are considered starting from 0 , 1 is added to m ; update n for next recursive call ; Driver program to test above functions
Swap bits in a given number | C Program to swap bits in a given number ; Move all bits of first set to rightmost side ; Move all bits of second set to rightmost side ; XOR the two sets ; Put the xor bits back to their original positions ; XOR the ' xor ' with the original number so that the two sets are swapped ; Driver program to test above function
Smallest of three integers without comparison operators | C program to find Smallest of three integers without comparison operators ; Driver code
Smallest of three integers without comparison operators | C implementation of above approach ; Function to find minimum of x and y ; Function to find minimum of 3 numbers x , y and z ; Driver code
Smallest of three integers without comparison operators |  ; Using division operator to find minimum of three numbers ; Same as " if ▁ ( y ▁ < ▁ x ) " ; Driver code
A Boolean Array Puzzle |  ; Driver code
Program to count number of set bits in an ( big ) array |  ; Size of array 64 K ; GROUP_A - When combined with META_LOOK_UP generates count for 4 x4 elements ; GROUP_B - When combined with META_LOOK_UP generates count for 4 x4x4 elements ; GROUP_C - When combined with META_LOOK_UP generates count for 4 x4x4x4 elements ; Provide appropriate letter to generate the table ; A static table will be much faster to access ; No shifting funda ( for better readability ) ; It is fine , bypass the type system ; Count set bits in individual bytes ; Driver program , generates table of random 64 K numbers ; Seed to the random - number generator ; Generate random numbers .
Add 1 to a given number | C ++ code to add add one to a given number ; Flip all the set bits until we find a 0 ; flip the rightmost 0 bit ; Driver program to test above functions
Add 1 to a given number |  ; Driver program to test above functions
Turn off the rightmost set bit |  ; unsets the rightmost set bit of n and returns the result ; Driver Code
Find whether a given number is a power of 4 or not |  ; Function to check if x is power of 4 ; Driver program to test above function
Find whether a given number is a power of 4 or not |  ; Function to check if x is power of 4 ; Check if there is only one bit set in n ; count 0 bits before set bit ; If count is even then return true else false ; If there are more than 1 bit set then n is not a power of 4 ; Driver program to test above function
Find whether a given number is a power of 4 or not | C program to check if given number is power of 4 or not ; Driver program to test above function
Compute the minimum or maximum of two integers without branching | C program to Compute the minimum or maximum of two integers without branching ; Function to find minimum of x and y ; Function to find maximum of x and y ; Driver program to test above functions
Compute the minimum or maximum of two integers without branching |  ; Function to find minimum of x and y ; Function to find maximum of x and y ; Driver program to test above functions
Check for Integer Overflow |  ; Takes pointer to result and two numbers as arguments . If there is no overflow , the function places the resultant = sum a + b in result and returns 0 , otherwise it returns - 1 ; Driver code
Check for Integer Overflow | 
Little and Big Endian Mystery | 
Position of rightmost set bit | C program for Position of rightmost set bit ; Driver code
Binary representation of a given number |  ; bin function ; Driver Code
Swap all odd and even bits | C program to swap even and odd bits of a given number ; Function to swap even and odd bits ; Get all even bits of x ; Get all odd bits of x ; Right shift even bits ; Left shift odd bits ; Combine even and odd bits ; Driver program to test above function ; 00010111 ; Output is 43 ( 00101011 )
Find position of the only set bit | C program to find position of only set bit in a given number ; A utility function to check whether n is a power of 2 or not . goo . gl / 17 Arj See http : ; Returns position of the only set bit in ' n ' ; Iterate through bits of n till we find a set bit i & n will be non - zero only when ' i ' and ' n ' have a set bit at same position ; Unset current bit and set the next bit in ' i ' ; increment position ; Driver program to test above function
Find position of the only set bit | C program to find position of only set bit in a given number ; A utility function to check whether n is power of 2 or not ; Returns position of the only set bit in ' n ' ; One by one move the only set bit to right till it reaches end ; increment count of shifts ; Driver program to test above function
How to swap two numbers without using a temporary variable ? | C Program to swap two numbers without using temporary variable ; Code to swap ' x ' and ' y ' x now becomes 50 ; y becomes 10 ; x becomes 5
How to swap two numbers without using a temporary variable ? | C code to swap using XOR ; Code to swap ' x ' ( 1010 ) and ' y ' ( 0101 ) x now becomes 15 ( 1111 ) ; y becomes 10 ( 1010 ) ; x becomes 5 ( 0101 )
How to swap two numbers without using a temporary variable ? | C program to implement the above approach ; Swap function ; Driver code
Replace every element with the greatest element on right side | C Program to replace every element with the greatest element on right side ; Function to replace every element with the next greatest element ; Initialize the next greatest element ; The next greatest element for the rightmost element is always - 1 ; Replace all other elements with the next greatest ; Store the current element ( needed later for updating the next greatest element ) ; Replace current element with the next greatest ; Update the greatest element , if needed ; A utility Function that prints an array ; Driver program to test above function
Maximum difference between two elements such that larger element appears after the smaller number |  ; The function assumes that there are at least two elements in array . The function returns a negative value if the array is sorted in decreasing order . Returns 0 if elements are equal ; Driver program to test above function ; Function calling
Find the maximum element in an array which is first increasing and then decreasing | C program to find maximum element ; function to find the maximum element ; Driver program to check above functions
Find the maximum element in an array which is first increasing and then decreasing |  ; Base Case : Only one element is present in arr [ low . . high ] ; If there are two elements and first is greater then the first element is maximum ; If there are two elements and second is greater then the second element is maximum ; If we reach a point where arr [ mid ] is greater than both of its adjacent elements arr [ mid - 1 ] and arr [ mid + 1 ] , then arr [ mid ] is the maximum element ; If arr [ mid ] is greater than the next element and smaller than the previous element then maximum lies on left side of mid ; when arr [ mid ] is greater than arr [ mid - 1 ] and smaller than arr [ mid + 1 ] ; Driver program to check above functions
Count smaller elements on right side |  ; initialize all the counts in countSmaller array as 0 ; Utility function that prints out an array on a line ; Driver program to test above functions
Count smaller elements on right side |  ; An AVL tree node ; size of the tree rooted with this node ; A utility function to get maximum of two integers ; A utility function to get height of the tree rooted with N ; A utility function to size of the tree of rooted with N ; A utility function to get maximum of two integers ; Helper function that allocates a new node with the given key and NULL left and right pointers . ; new node is initially added at leaf ; A utility function to right rotate subtree rooted with y ; Perform rotation ; Update heights ; Update sizes ; Return new root ; A utility function to left rotate subtree rooted with x ; Perform rotation ; Update heights ; Update sizes ; Return new root ; Get Balance factor of node N ; Inserts a new key to the tree rotted with node . Also , updates * count to contain count of smaller elements for the new key ; 1. Perform the normal BST rotation ; UPDATE COUNT OF SMALLER ELEMENTS FOR KEY ; 2. Update height and size of this ancestor node ; 3. Get the balance factor of this ancestor node to check whether this node became unbalanced ; Left Left Case ; Right Right Case ; Left Right Case ; Right Left Case ; return the ( unchanged ) node pointer ; The following function updates the countSmaller array to contain count of smaller elements on right side . ; initialize all the counts in countSmaller array as 0 ; Starting from rightmost element , insert all elements one by one in an AVL tree and get the count of smaller elements ; Utility function that prints out an array on a line ; Driver program to test above functions
Find the smallest positive number missing from an unsorted array | Set 1 | C program to find the smallest positive missing number ; Utility to swap to integers ; Utility function that puts all non - positive ( 0 and negative ) numbers on left side of arr [ ] and return count of such numbers ; increment count of non - positive integers ; Find the smallest positive missing number in an array that contains all positive integers ; Mark arr [ i ] as visited by making arr [ arr [ i ] - 1 ] negative . Note that 1 is subtracted because index start from 0 and positive numbers start from 1 ; Return the first index value at which is positive ; 1 is added because indexes start from 0 ; Find the smallest positive missing number in an array that contains both positive and negative integers ; First separate positive and negative numbers ; Shift the array and call findMissingPositive for positive part ; Driver code
Find the Missing Number |  ; getMissingNo takes array and size of array as arguments ; program to test above function
Find the repeating and the missing | Added 3 new methods | C program to Find the repeating and missing elements ; Driver code
Find the repeating and the missing | Added 3 new methods | C program to Find the repeating and missing elements ; The output of this function is stored at * x and * y ; Will hold xor of all elements and numbers from 1 to n ; Will have only single set bit of xor1 ; Get the xor of all array elements ; XOR the previous result with numbers from 1 to n ; Get the rightmost set bit in set_bit_no ; Now divide elements in two sets by comparing rightmost set bit of xor1 with bit at same position in each element . Also , get XORs of two sets . The two XORs are the output elements . The following two for loops serve the purpose ; arr [ i ] belongs to first set ; arr [ i ] belongs to second set ; i belongs to first set ; i belongs to second set ; * x and * y hold the desired output elements ; Driver program to test above function
Find four elements that sum to a given value | Set 1 ( n ^ 3 solution ) |  ; A naive solution to print all combination of 4 elements in A [ ] with sum equal to X ; Fix the first element and find other three ; Fix the second element and find other two ; Fix the third element and find the fourth ; find the fourth ; Driver program to test above function
Find four elements that sum to a given value | Set 2 | C program to find 4 elements with given sum ; The following structure is needed to store pair sums in aux [ ] ; index ( int A [ ] ) of first element in pair ; index of second element in pair ; sum of the pair ; Following function is needed for library function qsort ( ) ; Function to check if two given pairs have any common element or not ; The function finds four elements with given sum X ; Create an auxiliary array to store all pair sums ; Generate all possible pairs from A [ ] and store sums of all possible pairs in aux [ ] ; Sort the aux [ ] array using library function for sorting ; Now start two index variables from two corners of array and move them toward each other . ; Driver code ; Function call
Minimum distance between two occurrences of maximum | C program to find Min distance of maximum element ; function to return min distance ; case a ; case b ; case c ; driver program
Search an element in a Linked List ( Iterative and Recursive ) | Recursive C program to search an element in linked list ; Link list node ; Given a reference ( pointer to pointer ) to the head of a list and an int , push a new node on the front of the list . ; allocate node put in the key ; link the old list off the new node ; move the head to point to the new node ; Checks whether the value x is present in linked list ; Base case ; If key is present in current node , return true ; Recur for remaining list ; Driver program to test count function ; Start with the empty list ; Use push ( ) to construct below list 14 -> 21 -> 11 -> 30 -> 10
Delete alternate nodes of a Linked List | deletes alternate nodes of a list starting with head ; Change the next link of head ; free memory allocated for node ; Recursively call for the new next of head
Alternating split of a given Singly Linked List | Set 1 |  ; points to the last node in ' a ' ; points to the last node in ' b ' ; add at ' a ' tail ; advance the ' a ' tail
Identical Linked Lists | An iterative C program to check if two linked lists are identical or not ; Structure for a linked list node ; Returns true if linked lists a and b are identical , otherwise false ; If we reach here , then a and b are not NULL and their data is same , so move to next nodes in both lists ; If linked lists are identical , then ' a ' and ' b ' must be NULL at this point . ; Given a reference ( pointer to pointer ) to the head of a list and an int , push a new node on the front of the list . ; allocate node put in the data ; link the old list off the new node ; move the head to point to the new node ; Driver program to test above function ; The constructed linked lists are : a : 3 -> 2 -> 1 b : 3 -> 2 -> 1
Identical Linked Lists | A recursive C function to check if two linked lists are identical or not ; If both lists are empty ; If both lists are not empty , then data of current nodes must match , and same should be recursively true for rest of the nodes . ; If we reach here , then one of the lists is empty and other is not
Sort a linked list of 0 s , 1 s and 2 s | C Program to sort a linked list 0 s , 1 s or 2 s ; Link list node ; Function to sort a linked list of 0 s , 1 s and 2 s ; Initialize count of '0' , '1' and '2' as 0 ; count total number of '0' , '1' and '2' * count [ 0 ] will store total number of '0' s * count [ 1 ] will store total number of '1' s * count [ 2 ] will store total number of '2' s ; Let say count [ 0 ] = n1 , count [ 1 ] = n2 and count [ 2 ] = n3 * now start traversing list from head node , * 1 ) fill the list with 0 , till n1 > 0 * 2 ) fill the list with 1 , till n2 > 0 * 3 ) fill the list with 2 , till n3 > 0 ; Function to push a node ; allocate node put in the data ; link the old list off the new node ; move the head to point to the new node ; Function to print linked list ; Driver program to test above function ; Constructed Linked List is 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 8 -> 9 -> null
Flatten a multilevel linked list | 
Rearrange a linked list such that all even and odd positioned nodes are together | C program to rearrange a linked list in such a way that all odd positioned node are stored before all even positioned nodes ; Linked List Node ; A utility function to create a new node ; Rearranges given linked list such that all even positioned nodes are before odd positioned . Returns new head of linked List . ; Corner case ; Initialize first nodes of even and odd lists ; Remember the first node of even list so that we can connect the even list at the end of odd list . ; If there are no more nodes , then connect first node of even list to the last node of odd list ; Connecting odd nodes ; If there are NO more even nodes after current odd . ; Connecting even nodes ; A utility function to print a linked list ; Driver code
Delete last occurrence of an item from linked list | A C program to demonstrate deletion of last Node in singly linked list ; A linked list Node ; Function to delete the last occurrence ; If found key , update ; If the last occurrence is the last node ; If it is not the last node ; Utility function to create a new node with given key ; This function prints contents of linked list starting from the given Node ; Driver program to test above functions
Check whether the length of given linked list is Even or Odd | C program to check length of a given linklist ; Defining structure ; Function to check the length of linklist ; Push function ; Allocating node ; Info into node ; Next of new node to head ; head points to new node ; Driver function ; Adding elements to Linked List ; Checking for length of linklist
Merge two sorted linked lists |  ; point to the last result pointer ; tricky : advance to point to the next " . next " field
Make middle node head in a linked list | C program to make middle node as head of linked list . ; Link list node ; Function to get the middle and set at beginning of the linked list ; To traverse list nodes one by one ; To traverse list nodes by skipping one . ; To keep track of previous of middle ; for previous node of middle node ; move one node each time ; move two node each time ; set middle node at head ; To insert a node at the beginning of linked list . ; allocate node ; link the old list off the new node ; move the head to point to the new node ; A function to print a given linked list ; Driver function ; Create a list of 5 nodes
Doubly Linked List | Set 1 ( Introduction and Insertion ) | Given a node as prev_node , insert a new node after the given node ; 1. check if the given prev_node is NULL ; 2. allocate new node 3. put in the data ; 4. Make next of new node as next of prev_node ; 5. Make the next of prev_node as new_node ; 6. Make prev_node as previous of new_node ; 7. Change previous of new_node 's next node 
XOR Linked List â €“ A Memory Efficient Doubly Linked List | Set 2 | C Implementation of Memory efficient Doubly Linked List ; Node structure of a memory efficient doubly linked list ; XOR of next and previous node ; returns XORed value of the node addresses ; Insert a node at the beginning of the XORed linked list and makes the newly inserted node as head ; Allocate memory for new node ; Since new node is being inserted at the beginning , npx of new node will always be XOR of current head and NULL ; If linked list is not empty , then npx of current head node will be XOR of new node and node next to current head ; * ( head_ref ) -> npx is XOR of NULL and next . So if we do XOR of it with NULL , we get next ; Change head ; prints contents of doubly linked list in forward direction ; print current node ; get address of next node : curr -> npx is next ^ prev , so curr -> npx ^ prev will be next ^ prev ^ prev which is next ; update prev and curr for next iteration ; Driver program to test above functions ; Create following Doubly Linked List head -- > 40 < -- > 30 < -- > 20 < -- > 10 ; print the created list
Print nodes at k distance from root |  ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver program to test above functions ; Constructed binary tree is 1 / \ 2 3 / \ / 4 5 8
Print Binary Tree in 2 | Program to print binary tree in 2D ; A binary tree node ; Helper function to allocates a new node ; Function to print binary tree in 2D It does reverse inorder traversal ; Base case ; Increase distance between levels ; Process right child first ; Print current node after space count ; Process left child ; Wrapper over print2DUtil ( ) ; Pass initial space count as 0 ; Driver program to test above functions
Print Left View of a Binary Tree | C program to print left view of Binary Tree ; A utility function to create a new Binary Tree node ; Recursive function to print left view of a binary tree . ; Base Case ; If this is the first node of its level ; Recur for left and right subtrees ; A wrapper over leftViewUtil ( ) ; Driver code
Count number of rotated strings which have more number of vowels in the first half than second half | C implementation of the approach ; Function to return the count of rotated strings which have more number of vowels in the first half than the second half ; Compute the number of vowels in first - half ; Compute the number of vowels in second - half ; Check if first - half has more vowels ; Check for all possible rotations ; Return the answer ; Driver code ; Function call
Rotate Linked List block wise | C program to rotate a linked list block wise ; Link list node ; Recursive function to rotate one block ; Rotate Clockwise ; Rotate anti - Clockwise ; Function to rotate the linked list block wise ; If length is 0 or 1 return head ; if degree of rotation is 0 , return head ; Traverse upto last element of this block ; storing the first node of next block ; If nodes of this block are less than k . Rotate this block also ; Append the new head of next block to the tail of this block ; return head of updated Linked List ; Function to push a node ; Function to print linked list ; Driver program to test above function ; Start with the empty list ; create a list 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> NULL ; k is block size and d is number of rotations in every block .
Deletion at different positions in a Circular Linked List | Function to delete First node of Circular Linked List ; check if list doesn 't have any node  if not then return ; check if list have single node if yes then delete it and return ; traverse second node to first ; now previous is last node and first node ( firstNode ) link address put in last node ( previous ) link ; make second node as head node
Deletion at different positions in a Circular Linked List | Function delete last node of Circular Linked List ; check if list doesn 't have any node  if not then return ; check if list have single node if yes then delete it and return ; move first node to last previous
Efficient method to store a Lower Triangular Matrix using Column | C program for the above approach ; Dimensions of the matrix ; Structure of a memory efficient matrix ; Function to set the values in the Matrix ; Function to store the values in the Matrix ; Function to display the elements of the matrix ; Traverse the matrix ; Function to generate an efficient matrix ; Declare efficient Matrix ; Initialize the Matrix ; Set the values in matrix ; Return the matrix ; Driver Code ; Given Input ; Function call to create a memory efficient matrix ; Function call to print the Matrix
Count subarrays having sum of elements at even and odd positions equal | C program for the above approach ; Function to count subarrays in which sum of elements at even and odd positions are equal ; Initialize variables ; Iterate over the array ; Check if position is even then add to sum then add it to sum ; Else subtract it to sum ; Increment the count if the sum equals 0 ; Print the count of subarrays ; Driver Code ; Given array arr [ ] ; Size of the array ; Function call
Tail Recursion | An example of tail recursive function ; The last executed statement is recursive call
Print alternate elements of an array | C program to implement the above approach ; Function to print Alternate elements of the given array ; Print elements at odd positions ; If currIndex stores even index or odd position ; Driver Code
Shuffle 2 n integers as a1 | C program for the above approach ; Function to reverse the array from the position ' start ' to position ' end ' ; Stores mid of start and end ; Traverse the array in the range [ start , end ] ; Stores arr [ start + i ] ; Update arr [ start + i ] ; Update arr [ end - i ] ; Utility function to shuffle the given array in the of form { a1 , b1 , a2 , b2 , ... . an , bn } ; Stores the length of the array ; If length of the array is 2 ; Stores mid of the { start , end } ; Divide array into two halves of even length ; Update mid ; Calculate the mid - points of both halves of the array ; Reverse the subarray made from mid1 to mid2 ; Reverse the subarray made from mid1 to mid ; Reverse the subarray made from mid to mid2 ; Recursively calls for both the halves of the array ; Function to shuffle the given array in the form of { a1 , b1 , a2 , b2 , ... . an , bn } ; Function Call ; Print the modified array ; Driver Code ; Given array ; Size of the array ; Shuffles the given array to the required permutation
Check if two arrays can be made equal by reversing subarrays multiple times | C implementation to check if two arrays can be made equal ; Function to check if array B can be made equal to array A ; Sort both arrays ; Check both arrays equal or not ; Driver Code
Bubble Sort for Linked List by Swapping nodes | C program to sort Linked List using Bubble Sort by swapping nodes ; structure for a node ; Function to swap the nodes ; Function to sort the list ; update the link after swapping ; break if the loop ended without any swap ; Function to print the list ; Function to insert a struct Node at the beginning of a linked list ; Driver Code ; start with empty linked list ; Create linked list from the array arr [ ] ; print list before sorting ; sort the linked list ; print list after sorting
In | C ++ program in - place Merge Sort ; Merges two subarrays of arr [ ] . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ] Inplace Implementation ; If the direct merge is already sorted ; Two pointers to maintain start of both arrays to merge ; If element 1 is in right place ; Shift all the elements between element 1 element 2 , right by 1. ; Update all the pointers ; l is for left index and r is right index of the sub - array of arr to be sorted ; Same as ( l + r ) / 2 , but avoids overflow for large l and r ; Sort first and second halves ; Function to print an array ; Driver program to test above functions
Dual pivot Quicksort | C program to implement dual pivot QuickSort ; lp means left pivot , and rp means right pivot . ; p is the left pivot , and q is the right pivot . ; if elements are less than the left pivot ; if elements are greater than or equal to the right pivot ; bring pivots to their appropriate positions . ; returning the indices of the pivots . * lp = j ; because we cannot return two elements from a function . ; Driver code
Construct a graph using N vertices whose shortest distance between K pair of vertices is 2 | C program to implement the above approach ; Function to construct the simple and connected graph such that the distance between exactly K pairs of vertices is 2 ; Stores maximum possible count of edges in a graph ; Base Case ; Stores count of edges in a graph ; Connect all vertices of pairs ( i , j ) ; Update ; Driver Code
Find N distinct numbers whose Bitwise XOR is equal to K | C program for the above approach ; Function to find N integers having Bitwise XOR equal to K ; Base Cases ; Assign values to P and Q ; Stores Bitwise XOR of the first ( N - 3 ) elements ; Print the first N - 3 elements ; Calculate Bitwise XOR of first ( N - 3 ) elements ; Driver Code ; Function Call
Count of N digit Numbers whose sum of every K consecutive digits is equal | C program for the above approach ; Function to count the number of N - digit numbers such that sum of every k consecutive digits are equal ; Range of numbers ; Extract digits of the number ; Store the sum of first K digits ; Check for every k - consecutive digits ; If sum is not equal then break the loop ; Increment the count if it satisfy the given condition ; Driver code ; Given N and K ; Function call
Convert string to integer without using any in | C program for the above approach ; Function to convert string to integer without using functions ; Initialize a variable ; Iterate till length of the string ; Subtract 48 from the current digit ; Print the answer ; Driver Code ; Given string of number ; Function Call
Longest Arithmetic Progression | DP | The function returns true if there exist three elements in AP Assumption : set [ 0. . n - 1 ] is sorted . The code strictly implements the algorithm provided in the reference . ; One by fix every element as middle element ; Initialize i and k for the current j ; Find if there exist i and k that form AP with j as middle element
Maximum Sum Increasing Subsequence | DP | Dynamic Programming implementation of Maximum Sum Increasing Subsequence ( MSIS ) problem ; maxSumIS ( ) returns the maximum sum of increasing subsequence in arr [ ] of size n ; Initialize msis values for all indexes ; Compute maximum sum values in bottom up manner ; Pick maximum of all msis values ; Driver Code
C / C ++ Program for Longest Increasing Subsequence | A Naive C recursive implementation of LIS problem ; To make use of recursive calls , this function must return two things : 1 ) Length of LIS ending with element arr [ n - 1 ] . We use max_ending_here for this purpose 2 ) Overall maximum as the LIS may end with an element before arr [ n - 1 ] max_ref is used this purpose . The value of LIS of full array of size n is stored in * max_ref which is our final result ; Base case ; ' max _ ending _ here ' is length of LIS ending with arr [ n - 1 ] ; Recursively get all LIS ending with arr [ 0 ] , arr [ 1 ] ... arr [ n - 2 ] . If arr [ i - 1 ] is smaller than arr [ n - 1 ] , and max ending with arr [ n - 1 ] needs to be updated , then update it ; Compare max_ending_here with the overall max . And update the overall max if needed ; Return length of LIS ending with arr [ n - 1 ] ; The wrapper function for _lis ( ) ; The max variable holds the result ; The function _lis ( ) stores its result in max ; returns max ; Driver program to test above function
Overlapping Subproblems Property in Dynamic Programming | DP | a simple recursive program for Fibonacci numbers
Count of number of given string in 2D character array | C code for finding count of string in a given 2D character array . ; utility function to search complete string from any given index of 2d char array ; through Backtrack searching in every directions ; Function to search the string in 2d array ; Driver code
Check if given Parentheses expression is balanced or not | C program of the above approach ; Function to check if parentheses are balanced ; Initialising Variables ; Traversing the Expression ; It is a closing parenthesis ; This means there are more Closing parenthesis than opening ones ; If count is not zero , It means there are more opening parenthesis ; Driver code
Shortest distance to every other character from given character | C implementation of above approach ; Function to return required vector of distances ; list to hold position of c in s ; length of string ; To hold size of list ; Iterate over string to create list ; max value of p2 ; Initialize the pointers ; Create result array ; Values at current pointers ; Current Index is before than p1 ; Current Index is between p1 and p2 ; Current Index is nearer to p1 ; Current Index is nearer to p2 ; Move pointer 1 step ahead ; Current index is after p2 ; Driver code
Reverse String according to the number of words | C program to reverse string according to the number of words ; Reverse the letters of the word ; Temporary variable to store character ; Swapping the first and last character ; This function forms the required string ; Checking the number of words present in string to reverse ; Reverse the letter of the words ; Driver Code
Number of substrings with count of each character as k | 
Toggle case of a string using Bitwise Operators | C program to get toggle case of a string ; tOGGLE cASE = swaps CAPS to lower case and lower case to CAPS ; Bitwise EXOR with 32 ; Driver Code
Write your own atoi ( ) | 
Write your own strcmp that ignores cases |  ; implementation of strcmp that ignores cases ; If characters are same or inverting the 6 th bit makes them same ; Compare the last ( or first mismatching in case of not same ) characters ; Set the 6 th bit in both , then compare ; Driver program to test above function
Check whether two strings are anagram of each other | C program to check if two strings are anagrams of each other ; function to check whether two strings are anagram of each other ; Create 2 count arrays and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; If both strings are of different length . Removing this condition will make the program fail for strings like " aaca " and " aca " ; Compare count arrays ; Driver code ; Function Call
Heptacontagon Number | C program for above approach ; Finding the nth heptacontagon Number ; Driver code
Compute maximum of two integers in C / C ++ using Bitwise Operators | C program for the above approach ; Function to find the largest number ; Perform the subtraction ; Right shift and Bitwise AND ; Find the maximum number ; Return the maximum value ; Driver Code ; Function Call
C / C ++ program for Armstrong Numbers | C program to find Armstrong number ; Function to calculate N raised to the power D ; Function to calculate the order of the number ; For each digit ; Function to check whether the given number is Armstrong number or not ; Calling order function ; For each digit ; If satisfies Armstrong condition ; Driver Code ; Given Number N ; Function Call
C / C ++ Program to find Prime Numbers between given range | C program to find the prime numbers between a given interval ; Function for print prime number in given range ; Traverse each number in the interval with the help of for loop ; Skip 0 and 1 as they are neither prime nor composite ; flag variable to tell if i is prime or not ; Iterate to check if i is prime or not ; flag = 1 means i is prime and flag = 0 means i is not prime ; Driver Code ; Given Range ; Function Call
Check whether count of odd and even factors of a number are equal | C code for the above approach ; Function to check condition ; Driver Code
Lynch | C implementation for the above approach ; Function to check the divisibility of the number by its digit . ; If the digit divides the number then return true else return false . ; Function to check if all digits of n divide it or not ; Taking the digit of the number into digit var . ; Function to check if N has all distinct digits ; Create an array of size 10 and initialize all elements as false . This array is used to check if a digit is already seen or not . ; Traverse through all digits of given number ; Find the last digit ; If digit is already seen , return false ; Mark this digit as seen ; Remove the last digit from number ; Function to check Lynch - Bell numbers ; Driver Code ; Given number N ; Function call
Maximum Bitwise AND pair ( X , Y ) from given range such that X and Y can be same | C implementation to find the Maximum Bitwise AND pair ( X , Y ) from given range such that X and Y can be same ; Function to return the maximum bitwise AND ; Driver code
Average of Cubes of first N natural numbers | C program for the above approach ; Function to find average of cubes ; Store sum of cubes of numbers in the sum ; Calculate sum of cubes ; Return average ; Driver Code ; Given number ; Function Call
C / C ++ program to add N distances given in inch | C program for the above approach ; Struct defined for the inch - feet system ; Variable to store the inch - feet ; Function to find the sum of all N set of Inch Feet distances ; Variable to store sum ; Traverse the InchFeet array ; Find the total sum of feet and inch ; If inch sum is greater than 11 convert it into feet as 1 feet = 12 inch ; Find integral part of inch_sum ; Delete the integral part x ; Add x % 12 to inch_sum ; Add x / 12 to feet_sum ; Print the corresponding sum of feet_sum and inch_sum ; Driver Code ; Given set of inch - feet ; Function Call
Logarithm tricks for Competitive Programming | C implementation to check if the number is power of K ; Function to check if the number is power of K ; Logarithm function to calculate value ; Compare to the result1 or result2 both are equal ; Driver Code
Program for finding the Integral of a given function using Boole 's Rule | C program to implement Boole 's Rule on the given function ; Function to return the value of f ( x ) for the given value of x ; Function to computes the integrand of y at the given intervals of x with step size h and the initial limit a and final limit b ; Number of intervals ; Computing the step size ; Substituing a = 0 , b = 4 and h = 1 ; Driver code
Finding Integreand using Weedle 's Rule | C program to Implement Weedle 's Rule ; A sample function f ( x ) = 1 / ( 1 + x ^ 2 ) ; Function to find the integral value of f ( x ) with step size h , with initial lower limit and upper limit a and b ; Find step size h ; To store the final sum ; Find sum using Weedle 's Formula ; Return the final sum ; Driver Code ; lower limit and upper limit ; Function Call
Runge | C program to implement Runge Kutta method ; A sample differential equation " dy / dx ▁ = ▁ ( x ▁ - ▁ y ) /2" ; Finds value of y for a given x using step size h and initial value y0 at x0 . ; Count number of iterations using step size or step height h ; Iterate for number of iterations ; Apply Runge Kutta Formulas to find next value of y ; Update next value of y ; Update next value of x ; Driver Code
Perimeter and Area of Varignon 's Parallelogram | C program to find the perimeter and area ; Function to find the perimeter ; Function to find the area ; Driver code
Area of a leaf inside a square | C program to find the area of leaf inside a square ; Function to find area of leaf ; Driver code
Length of rope tied around three equal circles touching each other | C program to find the length of rope ; Function to find the length of rope ; Driver code
Area of Incircle of a Right Angled Triangle | C program to find the area of incircle of right angled triangle ; Function to find area of incircle ; Driver code
Area of Circumcircle of a Right Angled Triangle | C program to find the area of Cicumscribed circle of right angled triangle ; Function to find area of circumscribed circle ; Driver code
Program to calculate the Area and Perimeter of Incircle of an Equilateral Triangle | C program to find the area of Inscribed circle of equilateral triangle ; function to find area of inscribed circle ; function to find Perimeter of inscribed circle ; Driver code
Program to find the Area and Perimeter of a Semicircle | C program to find the Area and Perimeter of a Semicircle ; Function for calculating the area ; Formula for finding the area ; Function for calculating the perimeter ; Formula for finding the perimeter ; driver code ; Get the radius ; Find the area ; Find the perimeter
Program to find equation of a plane passing through 3 points | C program to find equation of a plane passing through given 3 points . ; Function to find equation of plane . ; Driver Code
Perpendicular distance between a point and a Line in 2 D | C program to find the distance between a given point and a given line in 2 D . ; Function to find distance ; Driver Code
Program to determine the octant of the axial plane | C program to print octant of a given point . ; Function to print octant ; Driver Code
Maximum area of quadrilateral | CPP program to find maximum are of a quadrilateral ; Calculating the semi - perimeter of the given quadrilateral ; Applying Brahmagupta 's formula to  get maximum area of quadrilateral ; Driver code
Find Array obtained after adding terms of AP for Q queries | C program for the above approach ; Function to find array after performing the given query to the array elements ; Traverse the given query ; Traverse the given array ; Update the value of A [ i ] ; Update the value of curr ; Print the array elements ; Driver Code ; Function Call
Estimating the value of Pi using Monte Carlo | Parallel Computing Method | C program for the above approach ; Function to find estimated value of PI using Monte Carlo algorithm ; Stores X and Y coordinates of a random point ; Stores distance of a random point from origin ; Stores number of points lying inside circle ; Stores number of points lying inside square ; Parallel calculation of random points lying inside a circle ; Initializes random points with a seed ; Finds random X co - ordinate ; Finds random X co - ordinate ; Finds the square of distance of point ( x , y ) from origin ; If d is less than or equal to 1 ; Increment pCircle by 1 ; Increment pSquare by 1 ; Stores the estimated value of PI ; Prints the value in pi ; Driver Code ; Input ; Function call
Efficient method to store a Lower Triangular Matrix using row | C program for the above approach ; Dimensions of a matrix ; Structure of the efficient matrix ; Function to set the values in the Matrix ; Function to store the values in the Matrix ; Function to display the elements of the matrix ; Traverse the matrix ; Function to generate an efficient matrix ; Declare efficient Matrix ; Initialize the Matrix ; Set the values in matrix ; Return the matrix ; Driver Code ; Stores the efficient matrix ; Print the Matrix
Modulo Operator ( % ) in C / C ++ with Examples | Program to illustrate the working of the modulo operator ; To store two integer values ; To store the result of the modulo expression
Program to compute log a to any base b ( logb a ) | C program to find log ( a ) on any base b ; Driver code
Program to compute log a to any base b ( logb a ) | C program to find log ( a ) on any base b using Recursion ; Recursive function to compute log a to the base b ; Driver code
Find Maximum and Minimum of two numbers using Absolute function | C program to find maximum and minimum using Absolute function ; Function to return maximum among the two numbers ; Function to return minimum among the two numbers ; Driver code ; Displaying the maximum value ; Displaying the minimum value
Program to Calculate e ^ x by Recursion ( using Taylor Series ) | C implementation of the approach ; Recursive Function with static variables p and f ; Termination condition ; Recursive call ; Update the power of x ; Factorial ; Driver code
Midpoint ellipse drawing algorithm | C program for implementing Mid - Point Ellipse Drawing Algorithm ; Initial decision parameter of region 1 ; For region 1 ; Print points based on 4 - way symmetry ; Checking and updating value of decision parameter based on algorithm ; Decision parameter of region 2 ; Plotting points of region 2 ; printing points based on 4 - way symmetry ; Checking and updating parameter value based on algorithm ; Driver code ; To draw a ellipse of major and minor radius 15 , 10 centred at ( 50 , 50 )
Program to Convert Hexadecimal Number to Binary | C program to convert Hexadecimal number to Binary ; function to convert Hexadecimal to Binary Number ; driver code ; Get the Hexadecimal number ; Convert HexaDecimal to Binary
How to access elements of a Square Matrix | C Program to read a square matrix and print the elements on secondary diagonal ; Get the square matrix ; Display the matrix ; Print the elements on secondary diagonal ; check for elements on secondary diagonal
How to access elements of a Square Matrix | C Program to read a square matrix and print the elements above secondary diagonal ; Get the square matrix ; Display the matrix ; Print the elements above secondary diagonal ; check for elements above secondary diagonal
How to access elements of a Square Matrix | C Program to read a square matrix and print the Corner Elements ; Get the square matrix ; Display the matrix ; Print the Corner elements ; check for corner elements
Program to calculate distance between two points in 3 D | C program to find distance between two points in 3 D . ; function to print distance ; Driver Code ; function call for distance
Find unique pairs such that each element is less than or equal to N | C program for finding the required pairs ; Finding the number of unique pairs ; Using the derived formula ; Printing the unique pairs ; Driver program to test above functions
Divide a big number into two parts that differ by k | C program to Divide a Big Number into two parts ; Function to adds two Numbers represented as array of character . ; length of string ; initializing extra character position to 0 ; Adding each element of character and storing the carry . ; If remainder remains . ; Function to subtracts two numbers represented by string . ; Finding the length of the string . ; initializing extra character position to 0. ; Substrating each element of character . ; Function divides a number represented by character array a constant . ; Dividing each character element by constant . ; Function to reverses the character array . ; Reversing the array . ; Wrapper Function ; Reversing the character array . ; Adding the each element of both array and storing the sum in array a [ ] . ; Dividing the array a [ ] by 2. ; Reversing the character array to get output . ; Substracting each element of array i . e calculating a = a - b ; Reversing the character array to get output . ; Driven Program
Area of a square from diagonal length | C Program to find the area of square when its diagonal is given . ; Returns area of square from given diagonal ; Driver function .
Average of Squares of Natural Numbers | C program to calculate 1 ^ 2 + 2 ^ 2 + 3 ^ 2 + ... average of square number ; Function to calculate average of square number ; Driver code
Program to get the Sum of series : 1 | C program to get the sum of the series ; Function to get the series ; Sum of n - 1 terms starting from 2 nd term ; Driver Code
Find largest prime factor of a number | C Program to find largest prime factor of number ; A function to find largest prime factor ; Initialize the maximum prime factor variable with the lowest one ; Print the number of 2 s that divide n ; n >>= 1 ; equivalent to n /= 2 ; n must be odd at this point ; now we have to iterate only for integers who does not have prime factor 2 and 3 ; This condition is to handle the case when n is a prime number greater than 4 ; Driver program to test above function
Sum of the Series 1 + x / 1 + x ^ 2 / 2 + x ^ 3 / 3 + . . + x ^ n / n | C program to find sum of series 1 + x ^ 2 / 2 + x ^ 3 / 3 + ... . + x ^ n / n ; C code to print the sum of the series ; Driver code
Chiliagon Number | C program for above approach ; Finding the nth chiliagon Number ; Driver program to test above function
Pentacontagon number | C program for above approach ; Finding the nth pentacontagon Number ; Driver program to test above function
Array value by repeatedly replacing max 2 elements with their absolute difference | C ++ program to find the array value by repeatedly replacing max 2 elements with their absolute difference ; function that return last value of array ; Build a binary max_heap . ; For max 2 elements ; Iterate until queue is not empty ; if only 1 element is left ; return the last remaining value ; check that difference is non zero ; finally return 0 ; Driver Code
Logarithm tricks for Competitive Programming | C implementation count the number of digits in a number ; Function to count the number of digits in a number ; Driver Code
Program to find the sum of the series 1 + x + x ^ 2 + x ^ 3 + . . + x ^ n | C implementation to find the sum of series 1 + x ^ 2 + x ^ 3 + ... . + x ^ n ; Function to print the sum of the series ; First Term of series ; Loop to find the N terms of the series ; Driver Code
Find the remainder when N is divided by 4 using Bitwise AND operator | C implementation to find N modulo 4 using Bitwise AND operator ; Function to find the remainder ; Bitwise AND with 3 ; return x ; Driver code
Program to print triangular number series till n | C Program to find Triangular Number Series ; Function to find triangular number ; For each iteration increase j by 1 and add it into k ; Increasing j by 1 ; Add value of j into k and update k ; Driven Function
Program to count digits in an integer ( 4 Different Methods ) | Recursive C program to count number of digits in a number ; Driver code
Check if a number is magic ( Recursive sum of digits is 1 ) | C program to check Whether the number is Magic or not . ; Accepting sample input ; Condition to check Magic number
Interesting facts about Fibonacci numbers | C program to demonstrate that Fibonacci numbers that are divisible by their indexes have indexes as either power of 5 or multiple of 12. ; storing Fibonacci numbers
Maximum value of an integer for which factorial can be calculated on a machine | C program to find maximum value of an integer for which factorial can be calculated on your system ; when fact crosses its size , it gives negative value ; Driver Code
Given a number n , find the first k digits of n ^ n | C ++ program to generate first k digits of n ^ n ; function to calculate first k digits of n ^ n ; take log10 of n ^ n . log10 ( n ^ n ) = n * log10 ( n ) ; We now try to separate the decimal and integral part of the / product . The floor function returns the smallest integer less than or equal to the argument . So in this case , product - floor ( product ) will give us the decimal part of product ; we now exponentiate this back by raising 10 to the power of decimal part ; We now try to find the power of 10 by which we will have to multiply the decimal part to obtain our final answer ; driver function
Multiply large integers under large modulo | C program of finding modulo multiplication ; Returns ( a * b ) % mod ; Update a if it is more than or equal to mod ; If b is odd , add a with result ; Here we assume that doing 2 * a doesn 't cause overflow ; b >>= 1 ; b = b / 2 ; Driver program
Check if a number can be expressed as a sum of consecutive numbers |  ; Updating n with 2 n ; ( n & ( n - 1 ) ) = > Checking whether we can write 2 n as 2 ^ k if yes ( can 't represent 2n as 2^k) then answer 1  if no (can represent 2n as 2^k) then answer 0
Combinatorial Game Theory | Set 2 ( Game of Nim ) | A C program to implement Game of Nim . The program assumes that both players are playing optimally ; A Structure to hold the two parameters of a move A move has two parameters - 1 ) pile_index = The index of pile from which stone is going to be removed 2 ) stones_removed = Number of stones removed from the pile indexed = pile_index ; A C function to output the current game state . ; A C function that returns True if game has ended and False if game is not yet over ; A C function to declare the winner of the game ; A C function to calculate the Nim - Sum at any point of the game . ; A C function to make moves of the Nim Game ; The player having the current turn is on a winning position . So he / she / it play optimally and tries to make Nim - Sum as 0 ; If this is not an illegal move then make this move . ; If you want to input yourself then remove the rand ( ) functions and modify the code to take inputs . But remember , you still won 't be able to change your  fate/prediction. ; Create an array to hold indices of non - empty piles ; A C function to play the Game of Nim ; Driver program to test above functions ; Test Case 1 ; We will predict the results before playing The COMPUTER starts first ; Let us play the game with COMPUTER starting first and check whether our prediction was right or not ; Test Case 2 int piles [ ] = { 3 , 4 , 7 } ; int n = sizeof ( piles ) / sizeof ( piles [ 0 ] ) ; We will predict the results before playing The HUMAN ( You ) starts first ; Let us play the game with COMPUTER starting first and check whether our prediction was right or not playGame ( piles , n , HUMAN ) ;
Program to find the Roots of Quadratic equation | C program to find roots of a quadratic equation ; Prints roots of quadratic equation ax * 2 + bx + x ; If a is 0 , then equation is not quadratic , but linear ; else d < 0 ; Driver code ; Function call
Convert from any base to decimal and vice versa | C program to convert a number from any base to decimal ; To return value of a char . For example , 2 is returned for '2' . 10 is returned for ' A ' , 11 for ' B ' ; Function to convert a number from given base ' b ' to decimal ; Initialize power of base ; Initialize result ; Decimal equivalent is str [ len - 1 ] * 1 + str [ len - 2 ] * base + str [ len - 3 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Driver code
Solving f ( n ) = ( 1 ) + ( 2 * 3 ) + ( 4 * 5 * 6 ) . . . n using Recursion | C Program to print the solution of the series f ( n ) = ( 1 ) + ( 2 * 3 ) + ( 4 * 5 * 6 ) . . . n using recursion ; Recursive function for finding sum of series calculated - number of terms till which sum of terms has been calculated current - number of terms for which sum has to becalculated N - Number of terms in the function to be calculated ; checking termination condition ; product of terms till current ; recursive call for adding terms next in the series ; Driver Code ; input number of terms in the series ; invoking the function to calculate the sum
Fibonacci Coding | C program for Fibonacci Encoding of a positive integer n ; To limit on the largest Fibonacci number to be used ; Array to store fibonacci numbers . fib [ i ] is going to store ( i + 2 ) 'th Fibonacci number ; Stores values in fib and returns index of the largest fibonacci number smaller than n . ; Fib [ 0 ] stores 2 nd Fibonacci No . ; Fib [ 1 ] stores 3 rd Fibonacci No . ; Keep Generating remaining numbers while previously generated number is smaller ; Return index of the largest fibonacci number smaller than or equal to n . Note that the above loop stopped when fib [ i - 1 ] became larger . ; Returns pointer to the char string which corresponds to code for n ; allocate memory for codeword ; index of the largest Fibonacci f <= n ; Mark usage of Fibonacci f ( 1 bit ) ; Subtract f from n ; Move to Fibonacci just smaller than f ; Mark all Fibonacci > n as not used ( 0 bit ) , progress backwards ; additional '1' bit ; return pointer to codeword ; driver function
Count number of squares in a rectangle | C program to count squares in a rectangle of size m x n ; Returns count of all squares in a rectangle of size m x n ; If n is smaller , swap m and n ; Now n is greater dimension , apply formula ; Driver Code
Segmented Sieve | This functions finds all primes smaller than ' limit ' using simple sieve of eratosthenes . ; Create a boolean array " mark [ 0 . . limit - 1 ] " and initialize all entries of it as true . A value in mark [ p ] will finally be false if ' p ' is Not a prime , else true . ; One by one traverse all numbers so that their multiples can be marked as composite . ; If p is not changed , then it is a prime ; Update all multiples of p ; Print all prime numbers and store them in prime
Modular multiplicative inverse | Iterative C program to find modular inverse using extended Euclid algorithm ; Returns modulo inverse of a with respect to m using extended Euclid Algorithm Assumption : a and m are coprimes , i . e . , gcd ( a , m ) = 1 ; q is quotient ; m is remainder now , process same as Euclid 's algo ; Update y and x ; Make x positive ; Driver Code ; Function call
Euler 's Totient Function | A simple C program to calculate Euler 's Totient Function ; Function to return gcd of a and b ; A simple method to evaluate Euler Totient Function ; Driver program to test above function
Euler 's Totient Function | C program to calculate Euler ' s ▁ Totient ▁ Function ▁ using ▁ Euler ' s product formula ; Consider all prime factors of n and for every prime factor p , multiply result with ( 1 - 1 / p ) ; Check if p is a prime factor . ; If yes , then update n and result ; If n has a prime factor greater than sqrt ( n ) ( There can be at - most one such prime factor ) ; Driver program to test above function
Program to print first n Fibonacci Numbers | Set 1 | C program to print first n Fibonacci numbers ; Function to print first n Fibonacci Numbers ; Driver Code
Program to find LCM of two numbers | C program to find LCM of two numbers ; Recursive function to return gcd of a and b ; Function to return LCM of two numbers ; Driver program to test above function
Program to convert a given number to words | C program to print a given number in words . The program handles numbers from 0 to 9999 ; A function that prints given number in words ; Base cases ; The first string is not used , it is to make array indexing simple ; The first string is not used , it is to make array indexing simple ; The first two string are not used , they are to make array indexing simple ; Used for debugging purpose only ; For single digit number ; Iterate while num is not ' \0' ; Code path for first 2 digits ; tens_power [ len - 3 ] ) ; here len can be 3 or 4 ; Code path for last 2 digits ; Need to explicitly handle 10 - 19. Sum of the two digits is used as index of " two _ digits " array of strings ; Need to explicitely handle 20 ; Rest of the two digit numbers i . e . , 21 to 99 ; Driver program to test above function
To find sum of two numbers without using any operator |  ; Driver code
Check if a number is multiple of 5 without using / and % operators | Assuming that integer takes 4 bytes , there can be maximum 10 digits in a integer ; Check the last character of string ; Driver Code
XOR Linked List | C program to implement the above approach ; Structure of a node in XOR linked list ; Stores data value of a node ; Stores XOR of previous pointer and next pointer ; Function to find the XOR of address of two nodes ; Function to insert a node with given value at given position ; If XOR linked list is empty ; Initialize a new Node ; Stores data value in the node ; Stores XOR of previous and next pointer ; Update pointer of head node ; If the XOR linked list is not empty ; Stores the address of current node ; Stores the address of previous node ; Initialize a new Node ; Update curr node address ; Update new node address ; Update head ; Update data value of current node ; Function to print elements of the XOR Linked List ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Traverse XOR linked list ; Print current node ; Forward traversal ; Update prev ; Update curr ; Reverse the linked list in group of K ; Stores head node ; If the XOR linked list is empty ; Stores count of nodes reversed in current group ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Reverse nodes in current group ; Forward traversal ; Update prev ; Update curr ; Update count ; Disconnect prev node from the next node ; Disconnect curr from previous node ; If the count of remaining nodes is less than K ; Update len ; Recursively process the next nodes ; Connect the head pointer with the prev ; Connect prev with the head ; Driver Code ; Create following XOR Linked List head -- > 7 < a > 6 < a > 8 < a > 11 < a > 3 < a > 1 < a > 2 < a > 0 ; Function Call ; Print the reversed list
XOR Linked List | C program for the above approach ; Structure of a node in XOR linked list ; Stores data value of a node ; Stores XOR of previous pointer and next pointer ; Function to find the XOR of two nodes ; Function to insert a node with given value at beginning position ; If XOR linked list is empty ; Initialize a new Node ; Stores data value in the node ; Stores XOR of previous and next pointer ; Update pointer of head node ; If the XOR linked list is not empty ; Stores the address of current node ; Stores the address of previous node ; Initialize a new Node ; Update curr node address ; Update new node address ; Update head ; Update data value of current node ; Function to print elements of the XOR Linked List ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Traverse XOR linked list ; Print current node ; Forward traversal ; Update prev ; Update curr ; Function to reverse the XOR linked list ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Forward traversal ; Update prev ; Update curr ; Update the head pointer ; Driver Code ; Create following XOR Linked List head -- > 40 < -- > 30 < -- > 20 < -- > 10 ; Reverse the XOR Linked List to give head -- > 10 < -- > 20 < -- > 30 < -- > 40
XOR Linked List | C program to implement the above approach ; Structure of a node in XOR linked list ; Stores data value of a node ; Stores XOR of previous pointer and next pointer ; Function to find the XOR of two nodes ; Function to insert a node with given value at given position ; If XOR linked list is empty ; Initialize a new Node ; Stores data value in the node ; Stores XOR of previous and next pointer ; Update pointer of head node ; If the XOR linked list is not empty ; Stores the address of current node ; Stores the address of previous node ; Initialize a new Node ; Update curr node address ; Update new node address ; Update head ; Update data value of current node ; Function to print elements of the XOR Linked List ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Traverse XOR linked list ; Print current node ; Forward traversal ; Update prev ; Update curr ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Forward traversal ; Update prev ; Update curr ; Forward traversal ; Update prev ; Update curr ; Driver Code ; Create following XOR Linked List head -- > 7 a > 6 a > 8 a > 11 a > 3 a > 1 a > 2 a > 0
XOR Linked List | C program to implement the above approach ; Structure of a node in XOR linked list ; Stores data value of a node ; Stores XOR of previous pointer and next pointer ; Function to find the XOR of two nodes ; Function to insert a node with given value at given position ; If XOR linked list is empty ; Initialize a new Node ; Stores data value in the node ; Stores XOR of previous and next pointer ; Update pointer of head node ; If the XOR linked list is not empty ; Stores the address of current node ; Stores the address of previous node ; Initialize a new Node ; Update curr node address ; Update new node address ; Update head ; Update data value of current node ; Function to print the middle node ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Traverse XOR linked list ; Forward traversal ; Update prev ; Update curr ; If the length of the linked list is odd ; If the length of the linked list is even ; Driver Code ; Create following XOR Linked List head -- > 4 a > 7 a > 5
XOR Linked List | C ++ program to implement the above approach ; Structure of a node in XOR linked list ; Stores data value of a node ; Stores XOR of previous pointer and next pointer ; Function to find the XOR of two nodes ; Function to insert a node with given value at given position ; If XOR linked list is empty ; If given position is equal to 1 ; Initialize a new Node ; Stores data value in the node ; Stores XOR of previous and next pointer ; Update pointer of head node ; If required position was not found ; If the XOR linked list is not empty ; Stores position of a node in the XOR linked list ; Stores the address of current node ; Stores the address of previous node ; Stores the XOR of next node and previous node ; Traverse the XOR linked list ; Update prev ; Update curr ; Update next ; Update Pos ; If the position of the current node is equal to the given position ; Initialize a new Node ; Stores pointer to previous Node as ( prev ^ next ^ next ) = prev ; Stores XOR of prev and new node ; Connecting new node with next ; Update pointer of next ; Connect node with curr and next curr < -- node -- > next ; Insertion node at beginning ; Initialize a new Node ; Update curr node address ; Update new node address ; Update head ; Update data value of current node ; Function to print elements of the XOR Linked List ; Stores XOR pointer in current node ; Stores XOR pointer of in previous Node ; Stores XOR pointer of in next node ; Traverse XOR linked list ; Print current node ; Forward traversal ; Update prev ; Update curr ; Driver Code ; Create following XOR Linked List head -- > 20 < -- > 40 < -- > 10 < -- > 30 ; Print the new list
Program to toggle K | C program to toggle K - th bit of a number N ; Function to toggle the kth bit of n ; Driver code
Program to clear K | C program to clear K - th bit of a number N ; Function to clear the kth bit of n ; Driver code
Left Shift and Right Shift Operators in C / C ++ | C ++ Program to demonstrate use of right shift operator ; a = 5 ( 00000101 ) , b = 9 ( 00001001 ) ; The result is 00000010 ; The result is 00000100
Left Shift and Right Shift Operators in C / C ++ |  ; shift y by 61 bits left
Left Shift and Right Shift Operators in C / C ++ | 
Bitwise recursive addition of two integers | C program to do recursive addition of two integers ; If bitwise & is 0 , then there is not going to be any carry . Hence result of XOR is addition . ; Driver code
Count total bits in a number | C program to find total bit in given number ; log function in base 2 take only integer part ; Driven program
Find the n | Efficient C program to find n - th palindrome ; Construct the nth binary palindrome with the given group number , aux_number and operation type ; No need to insert any bit in the middle ; Length of the final binary representation ; Fill first and last bit as 1 ; Start filling the a [ ] from middle , with the aux_num binary representation ; Get the auxiliary number 's ith bit and  fill around middle ; Insert bit 0 in the middle ; Length of the final binary representation ; Fill first and last bit as 1 ; Start filling the a [ ] from middle , with the aux_num binary representation ; Get the auxiliary number 's ith bit and fill  around middle ; else Insert bit 1 in the middle ; Length of the final binary representation ; Fill first and last bit as 1 ; Start filling the a [ ] from middle , with the aux_num binary representation ; Get the auxiliary number 's ith bit and fill  around middle ; Convert the number to decimal from binary ; Will return the nth binary palindrome number ; Add number of elements in all the groups , until the group of the nth number is found ; Total number of elements until this group ; Element 's offset position in the group ; Finding which bit to be placed in the middle and finding the number , which we will fill from the middle in both directions ; We need to fill this auxiliary number in binary form the middle in both directions ; op = 0 ; Need to Insert 0 at middle ; op = 1 ; Need to Insert 1 at middle ; Driver code ; Function Call
Toggle all the bits of a number except k | C program to toggle all bits except kth bit ; Returns a number with all bit toggled in n except k - th bit ; 1 ) Toggle k - th bit by doing n ^ ( 1 << k ) 2 ) Toggle all bits of the modified number ; Driver code
Operators in C | Set 2 ( Relational and Logical Operators ) | C program to demonstrate working of relational operators ; greater than example ; greater than equal to ; less than example ; lesser than equal to ; equal to ; not equal to
Operators in C | Set 2 ( Relational and Logical Operators ) | C program to demonstrate working of logical operators ; logical AND example ; logical OR example ; logical NOT example
Operators in C | Set 2 ( Relational and Logical Operators ) | 
How to swap two bits in a given integer ? | C program to swap bits in an integer ; This function swaps bit at positions p1 and p2 in an integer n ; Move p1 'th to rightmost side  ; Move p2 'th to rightmost side  ; XOR the two bits ; Put the xor bit back to their original positions ; XOR ' x ' with the original number so that the two sets are swapped ; Driver program to test above function
Write a function that returns 2 for input 1 and returns 1 for 2 | 
Write a function that returns 2 for input 1 and returns 1 for 2 | 
Bitwise Operators in C / C ++ |  ; Function to return the only odd occurring element ; Driver Method
Bitwise Operators in C / C ++ | 
Hamming code Implementation in C / C ++ | C program for the above approach ; Store input bits ; Store hamming code ; Function to calculate bit for ith position ; Traverse to store Hamming Code ; If current boit is 1 ; Update i ; Function to calculate hamming code ; Find msg bits having set bit at x 'th position of number ; Traverse the msgBits ; Update the code ; Update the code [ i ] to the input character at index j ; Traverse and update the hamming code ; Find current position ; Find value at current position ; Update the code ; Print the Hamming Code ; Driver Code ; Given input message Bit ; Function Call
First non | CPP program to find first non - repeating character using 1D array and one traversal . ; The function returns index of the first non - repeating character in a string . If all characters are repeating then returns INT_MAX ; Initialize all characters as absent . ; After below loop , the value of arr [ x ] is going to be index of of x if x appears only once . Else the value is going to be either - 1 or - 2. ; If this character occurs only once and appears before the current result , then update the result ; Driver program to test above function
Triacontagon Number | C program for above approach ; Finding the nth triacontagonal Number ; Driver program to test above function
Hexacontagon Number | C program for above approach ; Finding the nth hexacontagon Number ; Driver program to test above function
Enneacontagon Number | C program for above approach ; Finding the nth enneacontagon Number ; Driver program to test above function
Triacontakaidigon Number | C program for above approach ; Finding the nth triacontakaidigon Number ; Driver program to test above function
Icosihexagonal Number | C program for above approach ; Finding the nth Icosihexagonal Number ; Driver program to test above function
Icosikaioctagon or Icosioctagon Number | C program for above approach ; Finding the nth icosikaioctagonal Number ; Driver program to test above function
Octacontagon Number | C program for above approach ; Finding the nth octacontagon Number ; Driver program to test above function
Hectagon Number | C program for above approach ; Finding the nth hectagon Number ; Driver program to test above function
Tetracontagon Number | C program for above approach ; Finding the nth tetracontagon Number ; Driver program to test above function
Search an element in a reverse sorted array | C program for the above approach ; Function to search if element X is present in reverse sorted array ; Store the first index of the subarray in which X lies ; Store the last index of the subarray in which X lies ; Store the middle index of the subarray ; Check if value at middle index of the subarray equal to X ; Element is found ; If X is smaller than the value at middle index of the subarray ; Search in right half of subarray ; Search in left half of subarray ; If X not found ; Driver Code
Pancake sorting | C program to sort array using pancake sort ; Reverses arr [ 0. . i ] ; Returns index of the maximum element in arr [ 0. . n - 1 ] ; The main function that sorts given array using flip operations ; Start from the complete array and one by one reduce current size by one ; Find index of the maximum element in arr [ 0. . curr_size - 1 ] ; Move the maximum element to end of current array if it 's not already  at the end ; To move at the end , first move maximum number to beginning ; Now move the maximum number to end by reversing current array ; A utility function to print n array of size n ; Driver program to test above function
