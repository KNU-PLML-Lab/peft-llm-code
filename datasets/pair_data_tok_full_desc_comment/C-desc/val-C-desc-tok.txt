Program to print ' N ' alphabet using the number pattern from 1 to n | C implementation of the approach ; Function to print the desired Alphabet N Pattern ; Declaring the values of Right , Left and Diagonal values ; Main Loop for the rows ; For the left Values ; Spaces for the diagonals ; Condition for the diagonals ; Spaces for the Right Values ; For the right values ; Driver Code ; Size of the Pattern ; Calling the function to print the desired Pattern
Permutation Coefficient | A Dynamic Programming based solution that uses table P [ ] [ ] to calculate the Permutation Coefficient ; Returns value of Permutation Coefficient P ( n , k ) ; Calculate value of Permutation Coefficient in bottom up manner ; Base Cases ; Calculate value using previosly stored values ; This step is important as P ( i , j ) = 0 for j > i ; Driver Code
Permutation Coefficient | A O ( n ) solution that uses table fact [ ] to calculate the Permutation Coefficient ; Returns value of Permutation Coefficient P ( n , k ) ; base case ; Calculate value factorials up to n ; P ( n , k ) = n ! / ( n - k ) ! ; Driver Code
Dynamic Programming | A recursive solution for subset sum problem ; Returns true if there is a subset of set [ ] with sum equal to given sum ; Base Cases ; If last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following : ( a ) including the last element ( b ) excluding the last element ; Driver code
Pell Number | Iterative Pell Number Series in C ; calculate nth pell number ; driver function
Program for factorial of a number | C program to find factorial of given number ; function to find factorial of given number ; Driver Code
Largest subarray with equal number of 0 s and 1 s | A simple program to find the largest subarray with equal number of 0 s and 1 s ; This function Prints the starting and ending indexes of the largest subarray with equal number of 0 s and 1 s . Also returns the size of such subarray . ; Pick a starting point as i ; Consider all subarrays starting from i ; If this is a 0 sum subarray , then compare it with maximum size subarray calculated so far ; Driver program to test above functions
Ternary Search | C program to illustrate iterative approach to ternary search ; Function to perform Ternary Search ; Find the mid1 and mid2 ; Check if key is present at any mid ; Since key is not present at mid , check in which region it is present then repeat the Search operation in that region ; The key lies in between l and mid1 ; The key lies in between mid2 and r ; The key lies in between mid1 and mid2 ; Key not found ; Driver code ; Get the array Sort the array if not sorted ; Starting index ; length of array ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result
Find the minimum element in a sorted and rotated array | C program to find minimum element in a sorted and rotated array ; This condition is needed to handle the case when array is not rotated at all ; If there is only one element left ; Find mid ; Check if element ( mid + 1 ) is minimum element . Consider the cases like { 3 , 4 , 5 , 1 , 2 } ; Check if mid itself is minimum element ; Decide whether we need to go to left half or right half ; Driver program to test above functions
Find the smallest and second smallest elements in an array | C program to find smallest and second smallest elements ; For INT_MAX ; There should be atleast two elements ; If current element is smaller than first then update both first and second ; If arr [ i ] is in between first and second then update second ; Driver program to test above function
Subset Sum Problem in O ( sum ) space | Returns true if there exists a subset with given sum in arr [ ] ; The value of subset [ i % 2 ] [ j ] will be true if there exists a subset of sum j in arr [ 0 , 1 , ... . , i - 1 ] ; A subset with sum 0 is always possible ; If there exists no element no sum is possible ; Driver code
Majority Element | Program for finding out majority element in an array ; Function to find the candidate for Majority ; Function to check if the candidate occurs more than n / 2 * times ; Function to print Majority Element ; Find the candidate for Majority ; Print the candidate if it is Majority ; Driver code ; Function call
Dynamic Programming | A Dynamic Programming solution for subset sum problem ; Returns true if there is a subset of set [ ] with sum equal to given sum ; The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i ; If sum is 0 , then answer is true ; If sum is not 0 and set is empty , then answer is false ; Fill the subset table in bottom up manner ; uncomment this code to print table ; Driver code
Program to find whether a given number is power of 2 |  ; Function to check if x is power of 2 ; First x in the below expression is for the case when x is 0 ; Driver program to test above function
Smallest power of 2 greater than or equal to n | C program to find smallest power of 2 greater than or equal to n ; First n in the below condition is for the case where n is 0 ; Driver Code
Count ways to reach the nth stair using step 1 , 2 or 3 | A C program to count number of ways to reach n 't stair when ; A recursive function used by countWays ; Driver program to test above functions
Dynamic Programming | High | A naive recursive C program to find maximum tasks . ; Returns the maximum among the 2 numbers ; Returns maximum amount of task that can be done till day n ; If n is less than equal to 0 , then no solution exists ; Determines which task to choose on day n , then returns the maximum till that day ; Driver program to test above function
Count words in a given string | C program to count no of words from given input string . ; returns number of words in str ; word count ; Scan all characters one by one ; If next character is a separator , set the state as OUT ; If next character is not a word separator and state is OUT , then set the state as IN and increment word count ; Move to next character ; Driver program to tes above functions
Dynamic Programming | High | A DP based C ++ program to find maximum tasks . ; Returns the maximum among the 2 numbers ; Returns maximum amount of task that can be done till day n ; An array task_dp that stores the maximum task done ; If n = 0 , no solution exists ; If n = 1 , high effort task on that day will be the solution ; Fill the entire array determining which task to choose on day i ; Driver program to test above function
Partition problem | DP | A Dynamic Programming based C program to partition problem ; Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; Calculate sum of all elements ; initialize top row as true ; initialize leftmost column , except part [ 0 ] [ 0 ] , as 0 ; Fill the partition table in bottom up manner ; uncomment this part to print table ; Driver code ; Function call
DFA for Strings not ending with " THE " | C program to implement DFS that accepts all string that do not end with " THE " ; dfa tells the number associated with the present state ; This function is for the starting state ( zeroth ) of DFA ; On receiving ' T ' or ' t ' goto first state ( 1 ) ; This function is for the first state of DFA ; On receiving ' T ' or ' t ' goto first state ( 1 ) ; On receiving ' H ' or ' h ' goto second state ( 2 ) ; else goto starting state ( 0 ) ; This function is for the second state of DFA ; On receiving ' E ' or ' e ' goto third state ( 3 ) else goto starting state ( 0 ) ; This function is for the third state of DFA ; On receiving ' T ' or ' t ' goto first state ( 1 ) else goto starting state ( 0 ) ; store length of string ; driver code
Program to find the sum of a Series 1 + 1 / 2 ^ 2 + 1 / 3 ^ 3 + â €¦ . . + 1 / n ^ n | C program to calculate the following series ; Function to calculate the following series ; Driver Code
Ternary Search | C program to illustrate recursive approach to ternary search ; Function to perform Ternary Search ; Find the mid1 and mid2 ; Check if key is present at any mid ; Since key is not present at mid , check in which region it is present then repeat the Search operation in that region ; The key lies in between l and mid1 ; The key lies in between mid2 and r ; The key lies in between mid1 and mid2 ; Key not found ; Driver code ; Get the array Sort the array if not sorted ; Starting index ; length of array ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result
Program for addition of two matrices |  ; This function adds A [ ] [ ] and B [ ] [ ] , and stores the result in C [ ] [ ] ; Driver code
Program for subtraction of matrices |  ; This function subtracts B [ ] [ ] from A [ ] [ ] , and stores the result in C [ ] [ ] ; To store result
Find a Fixed Point ( Value equal to index ) in a given array | C program to check fixed point in an array using linear search ; If no fixed point present then return - 1 ; Driver program to check above functions
Find a Fixed Point ( Value equal to index ) in a given array | C program to check fixed point in an array using binary search ; low + ( high - low ) / 2 ; ; Return - 1 if there is no Fixed Point ; Driver program to check above functions
Linear Search | C code to linearly search x in arr [ ] . If x is present then return its location , otherwise return - 1 ; Driver code ; Function call
Counting Sort | C Program for counting sort ; The main function that sort the given string arr [ ] in alphabatical order ; The output character array that will have sorted arr ; Create a count array to store count of inidividul characters and initialize count array as 0 ; Store count of each character ; Change count [ i ] so that count [ i ] now contains actual position of this character in output array ; Build the output character array ; Copy the output array to arr , so that arr now contains sorted characters ; Driver program to test above function
Binomial Coefficient | DP | A Naive Recursive Implementation ; Returns value of Binomial Coefficient C ( n , k ) ; Base Cases ; Recur ; Driver program to test above function
How to print maximum number of A 's using given four keys | A recursive C program to print maximum number of A 's using  following four keys  ; A recursive function that returns the optimal length string for N keystrokes ; The optimal string length is N when N is smaller than 7 ; Initialize result ; TRY ALL POSSIBLE BREAK - POINTS For any keystroke N , we need to loop from N - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have Ctrl - A , Ctrl - C and then only Ctrl - V all the way . ; If the breakpoint is s at b 'th keystroke then  the optimal string would have length  (n-b-1)*screen[b-1]; ; Driver program ; for the rest of the array we will rely on the previous entries to compute new ones
How to print maximum number of A 's using given four keys | A Dynamic Programming based C program to find maximum number of A 's  that can be printed using four keys  ; this function returns the optimal length string for N keystrokes ; The optimal string length is N when N is smaller than 7 ; An array to store result of subproblems ; To pick a breakpoint ; Initializing the optimal lengths array for uptil 6 input strokes . ; Solve all subproblems in bottom manner ; Initialize length of optimal string for n keystrokes ; For any keystroke n , we need to loop from n - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have ctrl - a , ctrl - c and then only ctrl - v all the way . ; if the breakpoint is at b 'th keystroke then  the optimal string would have length  (n-b-1)*screen[b-1]; ; Driver program ; for the rest of the array we will rely on the previous entries to compute new ones
Write a program to calculate pow ( x , n ) |  ; Function to calculate x raised to the power y ; Program to test function power
Write a program to calculate pow ( x , n ) | Function to calculate x raised to the power y in O ( logn )
Write a program to calculate pow ( x , n ) | Extended version of power function that can work for float x and negative y ; Program to test function power
Babylonian method for square root |  ; Returns the square root of n . Note that the function ; We are using n itself as initial approximation This can definitely be improved ; e decides the accuracy level ; Driver program to test above function
Average of a stream of numbers |  ; Returns the new average after including x ; Prints average of a stream of numbers ; Driver program to test above functions
Space and time efficient Binomial Coefficient | Program to calculate C ( n , k ) ; Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- -- * 1 ] ; Driver program to test above function
Efficient program to print all prime factors of a given number | Program to print all prime factors ; A function to print all prime factors of a given number n ; Print the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Driver program to test above function
Print all possible combinations of r elements in a given array of size n | Program to print all combination of size r in an array of size n ; The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( ) ; A temporary array to store all combination one by one ; Print all combination using temprary array ' data [ ] ' ; arr [ ] -- -> Input Array data [ ] -- -> Temporary array to store current combination start & end -- -> Staring and Ending indexes in arr [ ] index -- -> Current index in data [ ] r -- -> Size of a combination to be printed ; Current combination is ready to be printed , print it ; replace index with all possible elements . The condition " end - i + 1 ▁ > = ▁ r - index " makes sure that including one element at index will make a combination with remaining elements at remaining positions ; Driver program to test above functions
Print all possible combinations of r elements in a given array of size n | Program to print all combination of size r in an array of size n ; The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( ) ; A temporary array to store all combination one by one ; Print all combination using temprary array ' data [ ] ' ; arr [ ] -- -> Input Array n -- -> Size of input array r -- -> Size of a combination to be printed index -- -> Current index in data [ ] data [ ] -- -> Temporary array to store current combination i -- -> index of current element in arr [ ] ; Current cobination is ready , print it ; When no more elements are there to put in data [ ] ; current is included , put next at next location ; current is excluded , replace it with next ( Note that i + 1 is passed , but index is not changed ) ; Driver program to test above functions
Count all possible groups of size 2 or 3 that have sum as multiple of 3 | C Program to count all possible groups of size 2 or 3 that have sum as multiple of 3 ; Returns count of all possible groups that can be formed from elements of a [ ] . ; Create an array C [ 3 ] to store counts of elements with remainder 0 , 1 and 2. c [ i ] would store count of elements with remainder i ; To store the result ; Count elements with remainder 0 , 1 and 2 ; Case 3. a : Count groups of size 2 from 0 remainder elements ; Case 3. b : Count groups of size 2 with one element with 1 remainder and other with 2 remainder ; Case 4. a : Count groups of size 3 with all 0 remainder elements ; Case 4. b : Count groups of size 3 with all 1 remainder elements ; Case 4. c : Count groups of size 3 with all 2 remainder elements ; Case 4. c : Count groups of size 3 with different remainders ; Return total count stored in res ; Driver program to test above functions
Smallest power of 2 greater than or equal to n |  ; First n in the below condition is for the case where n is 0 ; Driver Code
Smallest power of 2 greater than or equal to n |  ; Driver Code
Smallest power of 2 greater than or equal to n |  ; Finds next power of two for n . If n itself is a power of two then returns n ; Driver Code
Segregate 0 s and 1 s in an array | C program to sort a binary array in one pass ; Function to put all 0 s on left and all 1 s on right ; Initialize left and right indexes ; Increment left index while we see 0 at left ; Decrement right index while we see 1 at right ; If left is smaller than right then there is a 1 at left and a 0 at right . Exchange arr [ left ] and arr [ right ] ; driver program to test
Given an array arr [ ] , find the maximum j | C program for the above approach ; For a given array arr [ ] , returns the maximum j a i such that arr [ j ] > arr [ i ] ; Driver program to test above functions
Count ways to reach the nth stair using step 1 , 2 or 3 | Program to find n - th stair using step size 1 or 2 or 3. ; Returns count of ways to reach n - th stair using 1 or 2 or 3 steps . ; Driver code
Partition problem | DP | A recursive C program for partition problem ; A utility function that returns true if there is a subset of arr [ ] with sun equal to given sum ; Base Cases ; If last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element ; Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; Calculate sum of the elements in array ; If sum is odd , there cannot be two subsets with equal sum ; Find if there is subset with sum equal to half of total sum ; Driver code ; Function call
Find repeated character present first in a string | C program to find the first character that is repeated ; this is O ( N ^ 2 ) method ; Driver code
Reverse words in a given string | C program for above approach : ; temp is for word boundary ; STEP 1 of the above algorithm ; This condition is to make sure that the string start with valid character ( not space ) only ; STEP 2 of the above algorithm
Sum of all odd length palindromic numbers within the range [ L , R ] | C program to find the sum of all odd length palindromic numbers within the given range ; Function that returns true if the given number is a palindrome ; Here we are generating a new number ( reverse_num ) * by reversing the digits of original input number ; If the original input number ( num ) is equal to * to its reverse ( reverse_num ) then its palindrome * else it is not . ; Function that returns true if the given number is of odd length ; Function to return the sum of all odd length palindromic numbers within the given range ; if number is palindrome and of odd length ; Driver code
Subtract 1 without arithmetic operators | C code to subtract one from a given number ; Flip all the set bits until we find a 1 ; flip the rightmost 1 bit ; Driver program to test above functions
Sum of the multiples of two numbers below N | C program for above approach ; Function to return the sum of all the integers below N which are multiples of either A or B ; If i is a multiple of a or b ; Driver Code
Pell Number | Pell Number Series using Recursion in C ; calculate nth pell number ; driver function
Legendre 's formula (Given p and n, find the largest x such that p^x divides n!) | C program to find largest x such that p * x divides n ! ; Returns largest power of p that divides n ! ; Initialize result ; Calculate x = n / p + n / ( p ^ 2 ) + n / ( p ^ 3 ) + ... . ; Driver program
Program for factorial of a number | C ++ program to find factorial of given number ; single line to find factorial ; Driver Code
Extract ' k ' bits from a given position in a number . | C program to extract k bits from a given position . ; Function to extract k bits from p position and returns the extracted value as integer ; Driver code
Largest gap in an array | A C program to find largest gap between two elements in an array . ; function to solve the given problem ; Driver Code
Largest gap in an array | A C program to find largest gap between two elements in an array . ; function to solve the given problem ; finding maximum and minimum of an array ; Driver Code
